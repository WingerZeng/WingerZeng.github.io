<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Qt+OpenGL 搭建基本绘制框架</title>
    <url>/2019/10/25/Qt-OpenGL-%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%88%B6%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>一直觉得每次建立新的OpenGL工程，都要翻翻笔记，做一些复制粘贴的工作。于是我便产生了搭建一个比较通用的OpenGL模板的想法，最近又在学习Qt和设计模式，顺便将OpenGL与Qt相结合，并且亲手实践一些设计模式，权当练手罢。</p><a id="more"></a>
<h1 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h1><p>我首先新建立了一个Qt的工程，并且按下图建立工程目录。其中mainwindow就是应用的主窗口，glwidget.cpp文件定义了GLWidget类，openglmodel文件中定义了被绘制的模型类。我还新建了一个资源文件目录，用来存放各种着色器文件。<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025003743.png" alt></p>
<h1 id="GLWidget类"><a href="#GLWidget类" class="headerlink" title="GLWidget类"></a>GLWidget类</h1><p>GLWidget类是opengl的绘制对象，负责所有模型、着色器、用户交互。继承QOpenGLWidget类，并重写其中的initializeGL,paintGL,resizeGL虚函数，其分别对应初始化、绘制、窗体大小改变时会触发的回调函数。重写后的initializeGL主要负责一些opengl绘制环境初始化、着色器初始化、模型初始化的工作，而paintGL则相当于原生opengl中的绘制循环。</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul>
<li>opengl初始化工作要在initializeGL中进行，而不是构造函数中，并且记得调用initializeOpenGLFunctions。</li>
<li>我通过public继承了QOpenGLFunctions_4_3_Core类（可以换成其他版本）来调用opengl的函数，有些教程，包括官方文档上使用的是producted继承，但由于我要从模型类调用GLWidget类的opengl函数，所以改成了public继承，可能会导致一些封装性上的问题。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>glwidget.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GLWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLFunctions_4_3_Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLModel</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span> :</span> <span class="keyword">public</span> QOpenGLWidget, <span class="keyword">public</span> QOpenGLFunctions_4_3_Core</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GLWidget</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeGL</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintGL</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resizeGL</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget* father;</span><br><span class="line">    <span class="comment">//智能指针是个好习惯！</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;QOpenGLShaderProgram&gt; pShader;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;GLModel&gt; model;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GLWIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>glwidget.cpp </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglmodel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> GLWidgetTools &#123;</span><br><span class="line"><span class="comment">//加载shader文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initShader</span><span class="params">(QOpenGLShaderProgram *shader, QString vs, QString fs, QString gs=<span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Vertex, vs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(gs!=<span class="string">""</span>&amp;&amp;!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Geometry, gs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Fragment, fs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;link())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;bind())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shader-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">GLWidget::GLWidget(QWidget *parent) : QOpenGLWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    father = parent;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::initializeGL()</span><br><span class="line">&#123;</span><br><span class="line">    initializeOpenGLFunctions();</span><br><span class="line">    <span class="keyword">if</span>(father) setGeometry(<span class="number">0</span>,<span class="number">0</span>,father-&gt;width(),father-&gt;height());</span><br><span class="line">    qDebug()&lt;&lt; (<span class="keyword">const</span> <span class="keyword">char</span>*)glGetString(GL_VERSION)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//获取显卡opengl版本信息</span></span><br><span class="line">    <span class="comment">//glEnable(GL_DEPTH_TEST);</span></span><br><span class="line">    glClearColor(<span class="number">82.0</span>/<span class="number">255</span>, <span class="number">87.0</span>/<span class="number">255</span>, <span class="number">110.0</span>/<span class="number">255</span>,<span class="number">0.0</span>); <span class="comment">//设置背景色</span></span><br><span class="line">    glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    pShader.reset(<span class="keyword">new</span> QOpenGLShaderProgram);</span><br><span class="line">    <span class="comment">//shader文件用资源文件储存</span></span><br><span class="line">    GLWidgetTools::initShader(pShader.get(),<span class="string">":/shader/shader.vs"</span>,<span class="string">":/shader/shader.fs"</span>);</span><br><span class="line">    <span class="comment">//模型初始化，一个三角形</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; v(<span class="number">3</span>);</span><br><span class="line">    v[<span class="number">0</span>].Position=QVector3D(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    v[<span class="number">1</span>].Position=QVector3D(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    v[<span class="number">2</span>].Position=QVector3D(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    model.reset(<span class="keyword">new</span> GLModel(<span class="keyword">this</span>,v,i));</span><br><span class="line">    model-&gt;setupModel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::paintGL()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    glClearColor(<span class="number">82.0</span>/<span class="number">255</span>, <span class="number">87.0</span>/<span class="number">255</span>, <span class="number">110.0</span>/<span class="number">255</span>,<span class="number">0.00f</span>);</span><br><span class="line">    glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    model-&gt;Draw(pShader.get());</span><br><span class="line">    qDebug()&lt;&lt;glGetError();</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::resizeGL(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//改变窗体大小</span></span><br><span class="line">    setGeometry(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">    <span class="comment">//改变视口</span></span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::init()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="openglmodel类"><a href="#openglmodel类" class="headerlink" title="openglmodel类"></a>openglmodel类</h1><p>我主要想实现一个重用性较强的模型基类，说是模型类，其实其功能可以包含光照、摄像机矩阵等与着色器之间的交互。<br>实践了一下设计方法中的Template Method，将Draw函数视为一个绘制的模板，在其中处理一些绘制前后的通用步骤，而核心的绘制过程则作为虚函数交给派生类重写。</p>
<h3 id="注意点：-1"><a href="#注意点：-1" class="headerlink" title="注意点："></a>注意点：</h3><ul>
<li>在头文件中使用类声明，而不是文件包含，可以减小文件之间的编译耦合</li>
<li>对于一些数据量较大的模型，顶点位置数据应该交给一个模型类来存储，而其他模型类则共享该VBO</li>
</ul>
<figure class="highlight cpp"><figcaption><span>openglmodel.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OPENGLMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPENGLMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="comment">//在头文件中声明GLWidget类，在源文件中引入glwidget.h，减少编译耦合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span>;</span></span><br><span class="line"><span class="comment">//纹理类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Texture</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//顶点类</span></span><br><span class="line"><span class="comment">//结构体中内存连续存储,因此可以安心使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    QVector3D Position;</span><br><span class="line">    QVector3D Normal=QVector3D();</span><br><span class="line">    QVector2D TexCoords=QVector2D();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLModel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GLModel(GLWidget* f);</span><br><span class="line">    GLModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;());</span><br><span class="line">    <span class="comment">//当有多个对象使用同一个顶点数据时，由一个对象创建VBO，其他对象共享该VBO;</span></span><br><span class="line">    GLModel(GLWidget* f,<span class="keyword">unsigned</span> <span class="keyword">int</span> vbo,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;());</span><br><span class="line">    <span class="comment">//基类在绘制流程前后添加了一些通用步骤，子类重写绘制核心过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCamera</span><span class="params">(Camera* c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(QOpenGLShaderProgram* shader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupModel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//子类可以重写绘制的核心步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mainDraw</span><span class="params">(QOpenGLShaderProgram* shader)</span></span>;</span><br><span class="line">    GLWidget* father;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">//如果要使用纹理的话，在着色器uniform中要给纹理一个统一的编号规则</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO,VBO=<span class="number">0</span>,EBO;</span><br><span class="line">    <span class="comment">//目前来说空余的Camera对象</span></span><br><span class="line">    Camera* myCamera;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OPENGLMODEL_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>openglmodel.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglmodel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget *f):father(f)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i, <span class="built_in">vector</span>&lt;Texture&gt; t)</span><br><span class="line">    :father(f),vertices(v),indices(i),textures(t)&#123;&#125;</span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> vbo, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i, <span class="built_in">vector</span>&lt;Texture&gt; t)</span><br><span class="line">    :VBO(vbo),indices(i),textures(t)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::setCamera(Camera *c)</span><br><span class="line">&#123;</span><br><span class="line">    myCamera=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::setupModel()</span><br><span class="line">&#123;</span><br><span class="line">    father-&gt;glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    father-&gt;glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">//如果没有从其他对象共享VBO，则创建VBO</span></span><br><span class="line">    <span class="keyword">if</span>(VBO) father-&gt;glBindBuffer(GL_ARRAY_BUFFER,VBO);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        father-&gt;glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">        father-&gt;glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">        father-&gt;glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="keyword">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 顶点法线</span></span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//offsetof可以方便地设置结构体的偏移量</span></span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, Normal));</span><br><span class="line">        <span class="comment">// 顶点纹理坐标</span></span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, TexCoords));</span><br><span class="line">    &#125;</span><br><span class="line">    father-&gt;glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    father-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    father-&gt;glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>),</span><br><span class="line">                 &amp;indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    father-&gt;glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::mainDraw(QOpenGLShaderProgram *shader)</span><br><span class="line">&#123;</span><br><span class="line">    father-&gt;glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::Draw(QOpenGLShaderProgram* shader)&#123;</span><br><span class="line">    shader-&gt;bind();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">//如果没有纹理，跳过这一部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; textures.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father-&gt;glActiveTexture(GL_TEXTURE0 + i); <span class="comment">// 在绑定之前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></span><br><span class="line">        <span class="built_in">string</span> number;</span><br><span class="line">        <span class="built_in">string</span> name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">"texture_diffuse"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">"texture_specular"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(specularNr++);</span><br><span class="line"></span><br><span class="line">        shader-&gt;setUniformValue((<span class="string">"material."</span> + name + number).c_str(), i);</span><br><span class="line">        father-&gt;glBindTexture(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    father-&gt;glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    <span class="comment">// 绘制模型</span></span><br><span class="line">    father-&gt;glBindVertexArray(VAO);</span><br><span class="line">    mainDraw(shader);</span><br><span class="line">    father-&gt;glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    shader-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><p>最基础的shader，没啥好讲的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#version 430 core</span><br><span class="line">layout (location = 0) in vec3 aPos;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        gl_Position = vec4(aPos,1.0f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#version 430 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        FragColor = vec4(1.0f,1.0f,1.0f,1.0f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="主窗口"><a href="#主窗口" class="headerlink" title="主窗口"></a>主窗口</h1><p>mainwindow.ui中添加OpenGL Widget控件<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025012851.png" alt><br>右键OpenGL Widget控件，提升为<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025013003.png" alt><br>在提升的类名称中填入GLWidget，头文件则为glwidget.h，点击提升，该控件就继承了我们之前编写的GLWidget类</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>当当当当~一个boring的三角形<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025013326.png" alt></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>OpenGL</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>1087 All Roads Lead to Rome</title>
    <url>/2019/10/20/1087-All-Roads-Lead-to-Rome/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers N (2≤N≤200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.</p><a id="more"></a>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p>
<p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1-&gt;City2-&gt;…-&gt;ROM.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 7 HZH</span><br><span class="line">ROM 100</span><br><span class="line">PKN 40</span><br><span class="line">GDN 55</span><br><span class="line">PRS 95</span><br><span class="line">BLN 80</span><br><span class="line">ROM GDN 1</span><br><span class="line">BLN ROM 1</span><br><span class="line">HZH PKN 1</span><br><span class="line">PRS ROM 2</span><br><span class="line">BLN HZH 2</span><br><span class="line">PKN GDN 1</span><br><span class="line">HZH PRS 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 195 97</span><br><span class="line">HZH-&gt;PRS-&gt;ROM</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>我与其他主要有两点不同，一是用pass number，即通过的城市个数来等价代替了average glad参数。 因为遍历的时候average glad值不好根据上一个城市来递推，但pass number值可以。</p>
<p>第二个不同是没有将相同cost的路径存到一个二维数组中再进行后处理，我直接在Dijkstra算法中判断cost, glad, pass number参数，迭代结束生成的即为最优路径。关于总路径数的问题，我用一个diffpath变量，在迭代中根据父节点的情况来递推子节点的路径数。</p>
<p>具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">int</span> glad=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">vector</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;City&gt; c(<span class="number">26</span> * <span class="number">26</span> * <span class="number">26</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFINITE = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hah</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">	result += <span class="number">26</span> * <span class="number">26</span> * (s[<span class="number">0</span>] - <span class="string">'A'</span>);</span><br><span class="line">	result += <span class="number">26</span> * (s[<span class="number">1</span>] - <span class="string">'A'</span>);</span><br><span class="line">	result += (s[<span class="number">2</span>] - <span class="string">'A'</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">string</span> temps;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; temps;</span><br><span class="line">	<span class="keyword">int</span> start = hah(temps);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myc;</span><br><span class="line">	myc.push_back(start);</span><br><span class="line">	c[start].name = temps;</span><br><span class="line">	c[start].index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temps &gt;&gt; temp;</span><br><span class="line">		c[hah(temps)].name = temps;</span><br><span class="line">		c[hah(temps)].glad = temp;</span><br><span class="line">		myc.push_back(hah(temps));</span><br><span class="line">		c[hah(temps)].index = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> temps1, temps2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temps1 &gt;&gt; temps2 &gt;&gt; temp;</span><br><span class="line">		<span class="keyword">int</span> temp1 = hah(temps1);</span><br><span class="line">		<span class="keyword">int</span> temp2 = hah(temps2);</span><br><span class="line">		c[temp1].link.push_back(&#123;temp2,temp &#125;);</span><br><span class="line">		c[temp2].link.push_back(&#123; temp1,temp &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; collect(n,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n+<span class="number">1</span>, INFINITE);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; glad(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; passnum(n+<span class="number">1</span>,INFINITE);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffpath(n, <span class="number">0</span>);</span><br><span class="line">	dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	passnum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	diffpath[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> v=n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (collect[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (dist[i] &lt; dist[v]) &#123;</span><br><span class="line">				v = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (dist[i] == dist[v]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (glad[i] &gt; glad[v]) v = i;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (glad[i] == glad[v]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (passnum[i] &lt; passnum[v]) v = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (v == n) <span class="keyword">break</span>;</span><br><span class="line">		collect[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> now = myc[v];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c[now].link.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> cty = c[now];</span><br><span class="line">			<span class="keyword">if</span> (collect[c[cty.link[i].first].index]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">auto</span> nextcty = c[cty.link[i].first];</span><br><span class="line">			<span class="keyword">int</span> cost = cty.link[i].second;</span><br><span class="line">			<span class="keyword">if</span> (dist[nextcty.index] &gt; dist[cty.index] + cost) &#123;</span><br><span class="line">				<span class="comment">//刷新路径数为父节点的路径数</span></span><br><span class="line">				diffpath[nextcty.index] = diffpath[cty.index];</span><br><span class="line">				dist[nextcty.index] = dist[cty.index] + cost;</span><br><span class="line">				path[nextcty.index] = cty.index;</span><br><span class="line">				glad[nextcty.index] = glad[cty.index] + nextcty.glad;</span><br><span class="line">				passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (dist[nextcty.index] == dist[cty.index] + cost) &#123;</span><br><span class="line">				<span class="comment">//刷新路径数为本身路径数加上新增同等地位父节点的路径数</span></span><br><span class="line">				diffpath[nextcty.index]+=diffpath[cty.index];</span><br><span class="line">				<span class="keyword">if</span> (glad[nextcty.index] &lt; glad[cty.index] + nextcty.glad) &#123;</span><br><span class="line">					path[nextcty.index] = cty.index;</span><br><span class="line">					glad[nextcty.index] = glad[cty.index] + nextcty.glad;</span><br><span class="line">					passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (glad[nextcty.index] == glad[cty.index] + nextcty.glad) &#123;</span><br><span class="line">					<span class="keyword">if</span> (passnum[nextcty.index] &gt; passnum[cty.index] + <span class="number">1</span>) &#123;</span><br><span class="line">						path[nextcty.index] = cty.index;</span><br><span class="line">						passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">	<span class="keyword">int</span> cty = c[hah(<span class="string">"ROM"</span>)].index;</span><br><span class="line">	<span class="keyword">int</span> dis = cty;</span><br><span class="line">	<span class="keyword">int</span> totselect;</span><br><span class="line">	<span class="keyword">while</span> (cty != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">stack</span>.push_back(cty);</span><br><span class="line">		cty = path[cty];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; diffpath[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; dist[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; glad[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; glad[dis] / (<span class="keyword">int</span>)passnum[dis] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">bool</span> first = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (first) first = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c[myc[<span class="built_in">stack</span>.back()]].name;</span><br><span class="line">		<span class="built_in">stack</span>.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 为了加快城市关系建立，引入了一个哈希表，可能有些多余，反而使代码结构看起来有些杂乱。</p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1082 Read Number in Chinese</title>
    <url>/2019/10/17/PTA1082-Read-Number-in-Chinese/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai.</p><a id="more"></a>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-123456789</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100800</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yi Shi Wan ling ba Bai</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>可以按每四位来组织数字段，每个数字段有一个后缀，比如1-4位后缀为“”，5-8位后缀为“Wan”，9位后缀为“Yi”，每个数字段单独组织语言，如果数字段不全为0则加上相应后缀。每个数字段负责构造一个堆栈，栈顶为高位数字的对应字符串。、</p>
<p>0的处理：0的出现有以下几种情况</p>
<ul>
<li>高位0，比如0123，在栈顶加“ling”。</li>
<li>中间0，比如1203，在栈的中间位置加“ling”。</li>
<li>低位0，比如1230，不加。</li>
<li>全0，堆栈只有一个元素“ling”。</li>
</ul>
<p>将几个数字段的堆栈拼接为一个堆栈，栈顶为高位数字。<br>注意，还要对0进行后处理，因为之前对全0的处理方式会导致下面几个问题：</p>
<ul>
<li>0重复，比如1-0000-0100</li>
<li>出现低位上0，比如1000-0000</li>
</ul>
<p>因此，最后还要去除堆栈中重复的零，和栈底的零；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (first) first = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> num;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ds&#123; <span class="string">"ling"</span>,<span class="string">"yi"</span>,<span class="string">"er"</span>,<span class="string">"san"</span>,<span class="string">"si"</span>,<span class="string">"wu"</span>,<span class="string">"liu"</span>,<span class="string">"qi"</span>,<span class="string">"ba"</span>,<span class="string">"jiu"</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name1&#123;<span class="string">""</span>, <span class="string">" Shi"</span>,<span class="string">" Bai"</span>,<span class="string">" Qian"</span> &#125;; </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name2&#123;<span class="string">""</span>, <span class="string">" Wan"</span>,<span class="string">" Yi"</span> &#125;;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">stack</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="string">"0"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ling"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">		print(<span class="string">"Fu"</span>);</span><br><span class="line">		num.erase(num.begin());</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(num.begin(), num.end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size()/<span class="number">4</span>+(num.size()%<span class="number">4</span>?<span class="number">1</span>:<span class="number">0</span>); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">4</span>; j &lt; num.size() &amp;&amp; j &lt; (i + <span class="number">1</span>) * <span class="number">4</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">string</span> temp;</span><br><span class="line">			<span class="keyword">if</span> (num[j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">stack</span>[i].empty() &amp;&amp; <span class="built_in">stack</span>[i].back() != <span class="string">"ling"</span> &amp;&amp; <span class="built_in">stack</span>[i].back() != <span class="string">"Wan"</span>) <span class="built_in">stack</span>[i].push_back(<span class="string">"ling"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp += ds[num[j] - <span class="string">'0'</span>];</span><br><span class="line">			temp += name1[j % <span class="number">4</span>];</span><br><span class="line">			<span class="built_in">stack</span>[i].push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果全零</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">stack</span>.empty()) <span class="built_in">stack</span>[i].push_back(<span class="string">"ling"</span>);</span><br><span class="line">		<span class="comment">//不全零，则在栈底加上后缀</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">stack</span>[i].front() += name2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		s.insert(s.end(),<span class="built_in">stack</span>[i].begin(), <span class="built_in">stack</span>[i].end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it &lt; s.end() - <span class="number">1</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">"ling"</span> &amp;&amp; *(it + <span class="number">1</span>) == <span class="string">"ling"</span>) it = s.erase(it);</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it &lt; s.end();) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">"ling"</span>) it = s.erase(it);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">		print(s.back());</span><br><span class="line">		s.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较简洁，并且可拓展性比较强，当题目的位数限制提高后也能适用</p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1074 反转链表</title>
    <url>/2019/10/14/PTA1074-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<h2 id="解题关键"><a href="#解题关键" class="headerlink" title="解题关键"></a>解题关键</h2><p>用哈希表存储链表，在链表头需要另外插入一个空节点指向原链表头。<br>反转的迭代中需要三个临时指针，分别指向被反转节点及其之前、之后的位置。注意逆转节点段头尾的处理。注意链表尾边界情况的处理。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> key=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> val; </span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; ahash(<span class="number">100001</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root, n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; root &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> temp1, temp2, temp3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temp1 &gt;&gt; temp2 &gt;&gt; temp3;</span><br><span class="line">		ahash[temp1] = Node(&#123; temp1,temp2,temp3 &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	ahash[<span class="number">100000</span>].next = root;</span><br><span class="line">	<span class="keyword">int</span> it, preit, postit; <span class="comment">//分别指向节点段的末尾，节点段之前，节点段之后</span></span><br><span class="line">	it = root;</span><br><span class="line">	preit = <span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (it != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count != k) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			it = ahash[it].next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			postit = ahash[it].next;</span><br><span class="line">			<span class="keyword">int</span> tempit= ahash[preit].next;</span><br><span class="line">			<span class="keyword">int</span> tempit_ = ahash[tempit].next;</span><br><span class="line">			<span class="keyword">int</span> tempit__ = ahash[tempit_].next;</span><br><span class="line">			<span class="keyword">while</span>(tempit != it) &#123;</span><br><span class="line">				ahash[tempit_].next = tempit;</span><br><span class="line">				tempit = tempit_;</span><br><span class="line">				tempit_ = tempit__;</span><br><span class="line">				<span class="comment">//注意处理边界情况</span></span><br><span class="line">				<span class="keyword">if</span> (tempit__ != <span class="number">-1</span>)</span><br><span class="line">					tempit__ = ahash[tempit__].next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> newpre = ahash[preit].next;</span><br><span class="line">			ahash[newpre].next = postit;</span><br><span class="line">			ahash[preit].next = it;</span><br><span class="line"></span><br><span class="line">			preit = newpre;</span><br><span class="line">			it = postit;</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ahash[<span class="number">100000</span>].next; i != <span class="number">-1</span>; i = ahash[i].next) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ahash[i].next == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>, ahash[i].key, ahash[i].val);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, ahash[i].key, ahash[i].val, ahash[i].next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1038 数字段排序</title>
    <url>/2019/10/14/PTA1038-%E6%95%B0%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//核心，判断哪个数字段排前面的算法</span></span><br><span class="line"><span class="comment">//局部规划+贪婪？，本质上就是先乱序建立好一个数字段，</span></span><br><span class="line"><span class="comment">//交换两个数字段，如果交换后有提升，则采纳；如果无提升，就不采纳</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lhs, <span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> temp1 = lhs + rhs;</span><br><span class="line">	<span class="built_in">string</span> temp2 = rhs + lhs;</span><br><span class="line">	<span class="keyword">if</span> (temp1 &lt; temp2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (temp1 == temp2 &amp;&amp; temp1.size() &lt; temp2.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nums;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">string</span> temp;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">		nums.push_back(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(nums.begin(), nums.end(),cmp);</span><br><span class="line">	<span class="built_in">string</span> result;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">		result += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输入参数全0的情况</span></span><br><span class="line">	<span class="keyword">int</span> off = result.find_first_not_of(<span class="string">'0'</span>);</span><br><span class="line">	<span class="keyword">if</span> (off == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; result.substr(off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/14/myFirstTry/</url>
    <content><![CDATA[<h1 id="Winger强势入场"><a href="#Winger强势入场" class="headerlink" title="Winger强势入场"></a>Winger强势入场</h1><p>2019-10-14 经历了各种艰难，这个博客走起来了</p>
<img src="/2019/10/14/myFirstTry/1.jpg" title="走起！">]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
</search>
