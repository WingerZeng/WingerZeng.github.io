<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Qt+OpenGL 2.创建摄像机类</title>
    <url>/2019/10/25/Qt-OpenGL-%E5%88%9B%E5%BB%BA%E6%91%84%E5%83%8F%E6%9C%BA%E7%B1%BB/</url>
    <content><![CDATA[<p>上一篇文章中，我在Qt中搭建了一个Opengl绘制框架，并绘制了一个三角形，为了让朴实无华且枯燥的三角形动起来，我决定创建一个摄像机。\</p>
<a id="more"></a>
<h2 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h2><p>我创建了一个openglcamera.h文件，以及对应的cpp文件，用于安放摄像机类体系。什么，类体系?没错，我先创建了一个摄像机的抽象基类，称为AbstractCamera，并由此派生出其余的具体摄像机类。学c++，还是要多锻炼自己面向对象的思想。</p>
<p>首先要为摄像机类定义抽象接口，摄像机类公有的功能，一是要获取矩阵，二是要处理外界事件，比如按键、鼠标移动等。因此我在抽象类中声明了以下几个纯虚函数：</p>
<ul>
<li>virtual QMatrix4x4 getViewMatrix() 获取视图矩阵</li>
<li>virtual QMatrix4x4 getProjectMatrix() 获取投影矩阵</li>
<li>virtual void processEvent(Camera::Event e) 处理事件</li>
<li>virtual void processEvent(Camera::Event e,float xoffset) 重载函数，处理滚轮等事件</li>
<li>virtual void processEvent(Camera::Event e,float xoffset,float yoffset) 重载函数，处理鼠标移动等事件 </li>
</ul>
<p>其中对于processEvent()函数我重载了多个版本，因为对于不同的事件可能有不同的参数传递，比如鼠标移动事件就需要相对移动坐标参数。本来我想用可变长参数列表实现，但考虑到会使接口不是特别清晰，于是采用了重载的方法。</p>
<p>为了将三角形动起来，我通过上面定义的抽象摄像机，派生出一个CAD风格的摄像机类，命名为CADCamera。该类中有一些独有的成员变量，zoomSensitivity、rotateSensitivity等，用来控制摄像机的各项属性；最核心的旋转和缩放算法在processEvent()函数中，作者并不打算展开描述这些细节╮(╯3╰)╭；最后获取投影矩阵和视图矩阵则分别用到了Qt矩阵库中的QMatrix4x4::ortho()、QMatrix4x4::lookAt()函数（投影矩阵采用正投影）。</p>
<p>以下是代码：</p>
<figure class="highlight cpp"><figcaption><span>openglcamera.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OPENGLCAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPENGLCAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMatrix4x4&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span>;</span></span><br><span class="line"><span class="keyword">namespace</span> Camera&#123;</span><br><span class="line">    <span class="comment">//各种外界事件</span></span><br><span class="line">    <span class="keyword">enum</span> Event&#123;Up,Down,Left,Right,Mouse_Move,Mouse_Scroll&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个抽象的摄像机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCamera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AbstractCamera()=<span class="keyword">default</span>;</span><br><span class="line">    AbstractCamera(GLWidget* father,QVector3D pos,QVector3D front,QVector3D up);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getProjectMatrix</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理所有响应类事件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//滚轮、鼠标移动之类的事件，需要位移参数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset,<span class="keyword">float</span> yoffset)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//基类的析构函数也要设成虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractCamera();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    GLWidget* father;</span><br><span class="line">    QVector3D Position;</span><br><span class="line">    QVector3D Front;</span><br><span class="line">    QVector3D Up;</span><br><span class="line">    QVector3D Right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CADCamera</span>:</span> <span class="keyword">public</span> AbstractCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CADCamera(GLWidget* father,QVector3D pos);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getProjectMatrix</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset,<span class="keyword">float</span> yoffset)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseScroll</span><span class="params">(<span class="keyword">float</span> yoffset)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(<span class="keyword">float</span> xoffset, <span class="keyword">float</span> yoffset)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> zoomSensitivity;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> rotateSensitivity;</span><br><span class="line">    <span class="comment">//正交投影矩阵的基础宽度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> orthoWidth;</span><br><span class="line">    <span class="comment">//缩放比</span></span><br><span class="line">    <span class="keyword">float</span> Zoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OPENGLCAMERA_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>openglcamera.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglcamera.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTransform&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMatrix4x4&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line">AbstractCamera::AbstractCamera(GLWidget* father,QVector3D pos, QVector3D front, QVector3D up):</span><br><span class="line">    father(father),Position(pos),Front(front),Up(up)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前方向向量和上方向向量叉乘决定右方向向量</span></span><br><span class="line">    Right = QVector3D::crossProduct(front,up);</span><br><span class="line">    Right.normalize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractCamera::~AbstractCamera()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CADCamera::CADCamera(GLWidget* father,QVector3D pos):</span><br><span class="line">    AbstractCamera (father,pos,QVector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>),QVector3D(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0f</span>)),</span><br><span class="line">    zoomSensitivity(<span class="number">0.001</span>),rotateSensitivity(<span class="number">0.3</span>),orthoWidth(<span class="number">2.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Zoom = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QMatrix4x4 CADCamera::getViewMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    QMatrix4x4 viewMat;</span><br><span class="line">    viewMat.lookAt(Position,Position+Front,Up);</span><br><span class="line">    <span class="keyword">return</span> viewMat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QMatrix4x4 CADCamera::getProjectMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    QMatrix4x4 projectMat;</span><br><span class="line">    <span class="keyword">float</span> halfWid = orthoWidth*Zoom/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//opengl界面的高宽比</span></span><br><span class="line">    <span class="keyword">float</span> hw = father-&gt;height()*<span class="number">1.0</span>/father-&gt;width();</span><br><span class="line">    <span class="comment">//远平面和近平面的坐标看情况可以适当调大</span></span><br><span class="line">    projectMat.ortho(-halfWid,halfWid,-halfWid*hw,halfWid*hw,<span class="number">100.0f</span>,<span class="number">-100.0f</span>);</span><br><span class="line">    <span class="keyword">return</span> projectMat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::processEvent(Camera::Event e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::processEvent(Camera::Event e, <span class="keyword">float</span> xoffset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Camera;</span><br><span class="line">    <span class="keyword">switch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">case</span> Mouse_Scroll: ProcessMouseScroll(xoffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::processEvent(Camera::Event e, <span class="keyword">float</span> xoffset, <span class="keyword">float</span> yoffset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Camera;</span><br><span class="line">    <span class="keyword">switch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">case</span> Mouse_Move: ProcessMouseMovement(xoffset,yoffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::ProcessMouseScroll(<span class="keyword">float</span> yoffset)</span><br><span class="line">&#123;</span><br><span class="line">    Zoom -= yoffset*zoomSensitivity;</span><br><span class="line">    <span class="keyword">if</span>(Zoom&lt;=<span class="number">0.01</span>)</span><br><span class="line">        Zoom = <span class="number">0.01</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::ProcessMouseMovement(<span class="keyword">float</span> xoffset, <span class="keyword">float</span> yoffset)</span><br><span class="line">&#123;</span><br><span class="line">    xoffset *= rotateSensitivity;</span><br><span class="line">    yoffset *= rotateSensitivity;</span><br><span class="line"></span><br><span class="line">    QMatrix4x4 rotateX;</span><br><span class="line">    rotateX.rotate(xoffset,Up);</span><br><span class="line">    QMatrix4x4 rotateY;</span><br><span class="line">    rotateY.rotate(yoffset,Right);</span><br><span class="line">    Up = QVector3D(rotateY*QVector4D(Up,<span class="number">1.0</span>));</span><br><span class="line">    Position = QVector3D(rotateX*rotateY*QVector4D(Position,<span class="number">1.0</span>));</span><br><span class="line">    Front = -Position;</span><br><span class="line">    Front.normalize();</span><br><span class="line">    Right = QVector3D::crossProduct(Front,Up);</span><br><span class="line">    Right.normalize();</span><br><span class="line">    <span class="comment">//上述计算后Up会有微小误差，会形成累积误差，要修正Up，使三个方向向量保持90度关系</span></span><br><span class="line">    Up = -QVector3D::crossProduct(Front,Right);</span><br><span class="line">    Up.normalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新的着色器"><a href="#新的着色器" class="headerlink" title="新的着色器"></a>新的着色器</h2><p>由于加入了模型、视图、投影矩阵，所以需要新的顶点着色器。为每个矩阵设一个uniform变量，并乘到原始坐标上。</p>
<figure class="highlight cpp"><figcaption><span>CADshader.vs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 project;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = project*view*model*vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，为了给这个三角形一点颜色看看（give this triangel a little color see see），我在片段着色器中加入了代表颜色的uniform变量。</p>
<figure class="highlight cpp"><figcaption><span>CADshader.fs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">uniform vec4 myColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = myColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改GLWidget类"><a href="#修改GLWidget类" class="headerlink" title="修改GLWidget类"></a>修改GLWidget类</h2><p>为了适应新加入的摄像机类，GLWidget类中需要做一些修改。第一步是加入一个摄像机的成员变量，这里需要做一点手脚。不能直接为该摄像机变量声明成具体的CADCamera类，因为如果以后有更多的摄像机类了（如果有那一天的话），GLWidget的子类可能会需要另一个摄像机类，这样就需要为摄像机对象的类型留出更改空间。这里就要祭出工厂模式啦（Factory Method），在头文件中定义一个工厂虚函数，和一个指向抽象摄像机类的智能指针成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractCamera* <span class="title">cameraFactory</span><span class="params">()</span></span>; <span class="comment">//“摄像机工厂”</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;AbstractCamera&gt; pCamera;</span><br></pre></td></tr></table></figure>

<p>源文件中实现该工厂函数，在该版本的GLWidget中，工厂建立一个CADCamera对象，并以注意：工厂函数不能在GLWidget构造函数中调用，因为GLWiget的派生类在构造GLWiget类时，派生类本身没有构造完毕，因此调用的永远是GLWiget版本的cameraFactory()。</p>
<blockquote>
<p>绝不在构造和析构函数中调用virtual函数——“effective c++, item 9”</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbstractCamera *GLWidget::cameraFactory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CADCamera(<span class="keyword">this</span>,QVector3D(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">3.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在初始化函数中调用工厂函数</span></span><br><span class="line">GLWidget::GLWidget(QWidget *parent) : QOpenGLWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    father = parent;</span><br><span class="line">    pCamera.reset(cameraFactory());</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加新模型类"><a href="#增加新模型类" class="headerlink" title="增加新模型类"></a>增加新模型类</h2><p>为了迎合该摄像机，需要派生出一种新的CADModel类，类定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CADModel</span>:</span><span class="keyword">public</span> GLModel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CADModel(GLWidget* f)</span><br><span class="line">        :GLModel(f)&#123;&#125;;</span><br><span class="line">    CADModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;())</span><br><span class="line">        :GLModel(f,v,i,t)&#123;&#125;;</span><br><span class="line">    CADModel(GLWidget* f,<span class="keyword">unsigned</span> <span class="keyword">int</span> vbo,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;())</span><br><span class="line">        :GLModel(f,vbo,i,t)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mainDraw</span><span class="params">(QOpenGLShaderProgram* shader)</span> override</span>;</span><br><span class="line">    QMatrix4x4 modelMat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该类重写mainDraw()函数，在其中分配矩阵和颜色的Uniform，因为模型本身不做变换，模型矩阵即为单位矩阵。颜色上，使之随时间变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CADModel::mainDraw(QOpenGLShaderProgram *shader)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">float</span> t=clock()/<span class="number">200.0</span>;</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"model"</span>,modelMat);</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"view"</span>,myCamera-&gt;getViewMatrix());</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"project"</span>,myCamera-&gt;getProjectMatrix());</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"myColor"</span>,QVector4D(<span class="built_in">sin</span>(t)/<span class="number">2</span>+<span class="number">1</span>,<span class="built_in">cos</span>(<span class="built_in">sqrt</span>(<span class="number">2</span>)*t)/<span class="number">2</span>+<span class="number">1</span>,<span class="built_in">sin</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>)*t+<span class="number">0.5</span>)/<span class="number">2</span>+<span class="number">1</span>,<span class="built_in">cos</span>(<span class="built_in">sqrt</span>(<span class="number">4</span>)*t+<span class="number">0.6</span>)/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">    father-&gt;glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>魔幻三角！<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/123.gif" alt></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>OpenGL</tag>
        <tag>图形学</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt+OpenGL 基本绘制框架搭建</title>
    <url>/2019/10/25/Qt-OpenGL-%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%88%B6%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>每次建立新的OpenGL工程，都要翻翻笔记，做一些复制粘贴的工作，非常朴实无华且枯燥。于是我便产生了搭建一个比较通用的OpenGL模板的想法。最近又在学习Qt和设计模式，顺便将OpenGL与Qt相结合，并亲手实践一些设计模式，权当练手罢。</p><a id="more"></a>
<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><p>我首先新建立了一个Qt的工程，并且按下图建立工程目录。其中mainwindow就是应用的主窗口，glwidget.cpp文件定义了GLWidget类，openglmodel文件中定义了被绘制的模型类。我还新建了一个资源文件目录，用来存放各种着色器文件。<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025003743.png" alt></p>
<h2 id="GLWidget类"><a href="#GLWidget类" class="headerlink" title="GLWidget类"></a>GLWidget类</h2><p>GLWidget类是opengl的绘制对象，负责所有模型、着色器、用户交互。继承QOpenGLWidget类，并重写其中的initializeGL(),paintGL(),resizeGL()虚函数，其分别对应初始化、绘制、窗体大小改变时会触发的回调函数。重写后的initializeGL主要负责一些opengl绘制环境初始化、着色器初始化、模型初始化的工作，而paintGL则相当于原生opengl中的绘制循环。</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul>
<li>opengl初始化工作要在initializeGL()中进行，而不是构造函数中，并且记得调用initializeOpenGLFunctions。</li>
<li>我通过public继承了QOpenGLFunctions_4_3_Core类（可以换成其他版本）来调用opengl的函数，有些教程，包括官方文档上使用的是protected继承，但由于我要从模型类调用GLWidget类的opengl函数，所以改成了public继承，可能会导致一些封装性上的问题。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>glwidget.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GLWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLFunctions_4_3_Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLModel</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span> :</span> <span class="keyword">public</span> QOpenGLWidget, <span class="keyword">public</span> QOpenGLFunctions_4_3_Core</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GLWidget</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeGL</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintGL</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resizeGL</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget* father;</span><br><span class="line">    <span class="comment">//智能指针是个好习惯！</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;QOpenGLShaderProgram&gt; pShader;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;GLModel&gt; model;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GLWIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>glwidget.cpp </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglmodel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> GLWidgetTools &#123;</span><br><span class="line"><span class="comment">//加载shader文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initShader</span><span class="params">(QOpenGLShaderProgram *shader, QString vs, QString fs, QString gs=<span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Vertex, vs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(gs!=<span class="string">""</span>&amp;&amp;!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Geometry, gs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Fragment, fs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;link())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;bind())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shader-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">GLWidget::GLWidget(QWidget *parent) : QOpenGLWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    father = parent;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::initializeGL()</span><br><span class="line">&#123;</span><br><span class="line">    initializeOpenGLFunctions();</span><br><span class="line">    <span class="keyword">if</span>(father) setGeometry(<span class="number">0</span>,<span class="number">0</span>,father-&gt;width(),father-&gt;height());</span><br><span class="line">    qDebug()&lt;&lt; (<span class="keyword">const</span> <span class="keyword">char</span>*)glGetString(GL_VERSION)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//获取显卡opengl版本信息</span></span><br><span class="line">    <span class="comment">//glEnable(GL_DEPTH_TEST);</span></span><br><span class="line">    glClearColor(<span class="number">82.0</span>/<span class="number">255</span>, <span class="number">87.0</span>/<span class="number">255</span>, <span class="number">110.0</span>/<span class="number">255</span>,<span class="number">0.0</span>); <span class="comment">//设置背景色</span></span><br><span class="line">    glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    pShader.reset(<span class="keyword">new</span> QOpenGLShaderProgram);</span><br><span class="line">    <span class="comment">//shader文件用资源文件储存</span></span><br><span class="line">    GLWidgetTools::initShader(pShader.get(),<span class="string">":/shader/shader.vs"</span>,<span class="string">":/shader/shader.fs"</span>);</span><br><span class="line">    <span class="comment">//模型初始化，一个三角形</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; v(<span class="number">3</span>);</span><br><span class="line">    v[<span class="number">0</span>].Position=QVector3D(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    v[<span class="number">1</span>].Position=QVector3D(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    v[<span class="number">2</span>].Position=QVector3D(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    model.reset(<span class="keyword">new</span> GLModel(<span class="keyword">this</span>,v,i));</span><br><span class="line">    model-&gt;setupModel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::paintGL()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    glClearColor(<span class="number">82.0</span>/<span class="number">255</span>, <span class="number">87.0</span>/<span class="number">255</span>, <span class="number">110.0</span>/<span class="number">255</span>,<span class="number">0.00f</span>);</span><br><span class="line">    glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    model-&gt;Draw(pShader.get());</span><br><span class="line">    qDebug()&lt;&lt;glGetError();</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::resizeGL(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//改变窗体大小</span></span><br><span class="line">    setGeometry(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">    <span class="comment">//改变视口</span></span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::init()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="openglmodel类"><a href="#openglmodel类" class="headerlink" title="openglmodel类"></a>openglmodel类</h2><p>我主要想实现一个重用性较强的模型基类，说是模型类，其实其功能可以包含光照、摄像机矩阵等与着色器之间的交互。<br>实践了一下设计方法中的Template Method，将Draw()函数视为一个绘制的模板，在其中处理一些绘制前后的通用步骤，而核心的绘制过程则作为虚函数交给派生类重写。</p>
<h3 id="注意点：-1"><a href="#注意点：-1" class="headerlink" title="注意点："></a>注意点：</h3><ul>
<li>在头文件中使用类声明，而不是文件包含，可以减小文件之间的编译耦合</li>
<li>对于一些数据量较大的模型，顶点位置数据应该交给一个模型类来存储，而其他模型类则共享该VBO</li>
</ul>
<figure class="highlight cpp"><figcaption><span>openglmodel.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OPENGLMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPENGLMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="comment">//在头文件中声明GLWidget类，在源文件中引入glwidget.h，减少编译耦合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span>;</span></span><br><span class="line"><span class="comment">//纹理类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Texture</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//顶点类</span></span><br><span class="line"><span class="comment">//结构体中内存连续存储,因此可以安心使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    QVector3D Position;</span><br><span class="line">    QVector3D Normal=QVector3D();</span><br><span class="line">    QVector2D TexCoords=QVector2D();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLModel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GLModel(GLWidget* f);</span><br><span class="line">    GLModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;());</span><br><span class="line">    <span class="comment">//当有多个对象使用同一个顶点数据时，由一个对象创建VBO，其他对象共享该VBO;</span></span><br><span class="line">    GLModel(GLWidget* f,<span class="keyword">unsigned</span> <span class="keyword">int</span> vbo,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;());</span><br><span class="line">    <span class="comment">//基类在绘制流程前后添加了一些通用步骤，子类重写绘制核心过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCamera</span><span class="params">(Camera* c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(QOpenGLShaderProgram* shader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupModel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//子类可以重写绘制的核心步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mainDraw</span><span class="params">(QOpenGLShaderProgram* shader)</span></span>;</span><br><span class="line">    GLWidget* father;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">//如果要使用纹理的话，在着色器uniform中要给纹理一个统一的编号规则</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO,VBO=<span class="number">0</span>,EBO;</span><br><span class="line">    <span class="comment">//目前来说空余的Camera对象</span></span><br><span class="line">    Camera* myCamera;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OPENGLMODEL_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>openglmodel.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglmodel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget *f):father(f)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i, <span class="built_in">vector</span>&lt;Texture&gt; t)</span><br><span class="line">    :father(f),vertices(v),indices(i),textures(t)&#123;&#125;</span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> vbo, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i, <span class="built_in">vector</span>&lt;Texture&gt; t)</span><br><span class="line">    :VBO(vbo),indices(i),textures(t)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::setCamera(Camera *c)</span><br><span class="line">&#123;</span><br><span class="line">    myCamera=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::setupModel()</span><br><span class="line">&#123;</span><br><span class="line">    father-&gt;glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    father-&gt;glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">//如果没有从其他对象共享VBO，则创建VBO</span></span><br><span class="line">    <span class="keyword">if</span>(VBO) father-&gt;glBindBuffer(GL_ARRAY_BUFFER,VBO);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        father-&gt;glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">        father-&gt;glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">        father-&gt;glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="keyword">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 顶点法线</span></span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//offsetof可以方便地设置结构体的偏移量</span></span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, Normal));</span><br><span class="line">        <span class="comment">// 顶点纹理坐标</span></span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, TexCoords));</span><br><span class="line">    &#125;</span><br><span class="line">    father-&gt;glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    father-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    father-&gt;glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>),</span><br><span class="line">                 &amp;indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    father-&gt;glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::mainDraw(QOpenGLShaderProgram *shader)</span><br><span class="line">&#123;</span><br><span class="line">    father-&gt;glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::Draw(QOpenGLShaderProgram* shader)&#123;</span><br><span class="line">    shader-&gt;bind();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">//如果没有纹理，跳过这一部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; textures.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father-&gt;glActiveTexture(GL_TEXTURE0 + i); <span class="comment">// 在绑定之前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></span><br><span class="line">        <span class="built_in">string</span> number;</span><br><span class="line">        <span class="built_in">string</span> name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">"texture_diffuse"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">"texture_specular"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(specularNr++);</span><br><span class="line"></span><br><span class="line">        shader-&gt;setUniformValue((<span class="string">"material."</span> + name + number).c_str(), i);</span><br><span class="line">        father-&gt;glBindTexture(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    father-&gt;glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    <span class="comment">// 绘制模型</span></span><br><span class="line">    father-&gt;glBindVertexArray(VAO);</span><br><span class="line">    mainDraw(shader);</span><br><span class="line">    father-&gt;glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    shader-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>最基础的shader，没啥好讲的。</p>
<figure class="highlight cpp"><figcaption><span>shader.vs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        gl_Position = vec4(aPos,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>shader.fs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        FragColor = vec4(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主窗口"><a href="#主窗口" class="headerlink" title="主窗口"></a>主窗口</h2><p>mainwindow.ui中添加OpenGL Widget控件<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025012851.png" alt><br>右键OpenGL Widget控件，提升为<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025013003.png" alt><br>在提升的类名称中填入GLWidget，头文件则为glwidget.h，点击提升，该控件就继承了我们之前编写的GLWidget类</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>当当当当~一个朴实无华且枯燥的三角形<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025013326.png" alt></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>OpenGL</tag>
        <tag>图形学</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>1087 All Roads Lead to Rome</title>
    <url>/2019/10/20/1087-All-Roads-Lead-to-Rome/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers N (2≤N≤200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.</p><a id="more"></a>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p>
<p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1-&gt;City2-&gt;…-&gt;ROM.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 7 HZH</span><br><span class="line">ROM 100</span><br><span class="line">PKN 40</span><br><span class="line">GDN 55</span><br><span class="line">PRS 95</span><br><span class="line">BLN 80</span><br><span class="line">ROM GDN 1</span><br><span class="line">BLN ROM 1</span><br><span class="line">HZH PKN 1</span><br><span class="line">PRS ROM 2</span><br><span class="line">BLN HZH 2</span><br><span class="line">PKN GDN 1</span><br><span class="line">HZH PRS 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 195 97</span><br><span class="line">HZH-&gt;PRS-&gt;ROM</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>我与其他主要有两点不同，一是用pass number，即通过的城市个数来等价代替了average glad参数。 因为遍历的时候average glad值不好根据上一个城市来递推，但pass number值可以。</p>
<p>第二个不同是没有将相同cost的路径存到一个二维数组中再进行后处理，我直接在Dijkstra算法中判断cost, glad, pass number参数，迭代结束生成的即为最优路径。关于总路径数的问题，我用一个diffpath变量，在迭代中根据父节点的情况来递推子节点的路径数。</p>
<p>具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">int</span> glad=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">vector</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;City&gt; c(<span class="number">26</span> * <span class="number">26</span> * <span class="number">26</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFINITE = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hah</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">	result += <span class="number">26</span> * <span class="number">26</span> * (s[<span class="number">0</span>] - <span class="string">'A'</span>);</span><br><span class="line">	result += <span class="number">26</span> * (s[<span class="number">1</span>] - <span class="string">'A'</span>);</span><br><span class="line">	result += (s[<span class="number">2</span>] - <span class="string">'A'</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">string</span> temps;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; temps;</span><br><span class="line">	<span class="keyword">int</span> start = hah(temps);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myc;</span><br><span class="line">	myc.push_back(start);</span><br><span class="line">	c[start].name = temps;</span><br><span class="line">	c[start].index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temps &gt;&gt; temp;</span><br><span class="line">		c[hah(temps)].name = temps;</span><br><span class="line">		c[hah(temps)].glad = temp;</span><br><span class="line">		myc.push_back(hah(temps));</span><br><span class="line">		c[hah(temps)].index = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> temps1, temps2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temps1 &gt;&gt; temps2 &gt;&gt; temp;</span><br><span class="line">		<span class="keyword">int</span> temp1 = hah(temps1);</span><br><span class="line">		<span class="keyword">int</span> temp2 = hah(temps2);</span><br><span class="line">		c[temp1].link.push_back(&#123;temp2,temp &#125;);</span><br><span class="line">		c[temp2].link.push_back(&#123; temp1,temp &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; collect(n,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n+<span class="number">1</span>, INFINITE);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; glad(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; passnum(n+<span class="number">1</span>,INFINITE);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffpath(n, <span class="number">0</span>);</span><br><span class="line">	dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	passnum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	diffpath[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> v=n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (collect[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (dist[i] &lt; dist[v]) &#123;</span><br><span class="line">				v = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (dist[i] == dist[v]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (glad[i] &gt; glad[v]) v = i;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (glad[i] == glad[v]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (passnum[i] &lt; passnum[v]) v = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (v == n) <span class="keyword">break</span>;</span><br><span class="line">		collect[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> now = myc[v];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c[now].link.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> cty = c[now];</span><br><span class="line">			<span class="keyword">if</span> (collect[c[cty.link[i].first].index]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">auto</span> nextcty = c[cty.link[i].first];</span><br><span class="line">			<span class="keyword">int</span> cost = cty.link[i].second;</span><br><span class="line">			<span class="keyword">if</span> (dist[nextcty.index] &gt; dist[cty.index] + cost) &#123;</span><br><span class="line">				<span class="comment">//刷新路径数为父节点的路径数</span></span><br><span class="line">				diffpath[nextcty.index] = diffpath[cty.index];</span><br><span class="line">				dist[nextcty.index] = dist[cty.index] + cost;</span><br><span class="line">				path[nextcty.index] = cty.index;</span><br><span class="line">				glad[nextcty.index] = glad[cty.index] + nextcty.glad;</span><br><span class="line">				passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (dist[nextcty.index] == dist[cty.index] + cost) &#123;</span><br><span class="line">				<span class="comment">//刷新路径数为本身路径数加上新增同等地位父节点的路径数</span></span><br><span class="line">				diffpath[nextcty.index]+=diffpath[cty.index];</span><br><span class="line">				<span class="keyword">if</span> (glad[nextcty.index] &lt; glad[cty.index] + nextcty.glad) &#123;</span><br><span class="line">					path[nextcty.index] = cty.index;</span><br><span class="line">					glad[nextcty.index] = glad[cty.index] + nextcty.glad;</span><br><span class="line">					passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (glad[nextcty.index] == glad[cty.index] + nextcty.glad) &#123;</span><br><span class="line">					<span class="keyword">if</span> (passnum[nextcty.index] &gt; passnum[cty.index] + <span class="number">1</span>) &#123;</span><br><span class="line">						path[nextcty.index] = cty.index;</span><br><span class="line">						passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">	<span class="keyword">int</span> cty = c[hah(<span class="string">"ROM"</span>)].index;</span><br><span class="line">	<span class="keyword">int</span> dis = cty;</span><br><span class="line">	<span class="keyword">int</span> totselect;</span><br><span class="line">	<span class="keyword">while</span> (cty != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">stack</span>.push_back(cty);</span><br><span class="line">		cty = path[cty];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; diffpath[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; dist[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; glad[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; glad[dis] / (<span class="keyword">int</span>)passnum[dis] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">bool</span> first = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (first) first = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c[myc[<span class="built_in">stack</span>.back()]].name;</span><br><span class="line">		<span class="built_in">stack</span>.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 为了加快城市关系建立，引入了一个哈希表，可能有些多余，反而使代码结构看起来有些杂乱。</p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1082 Read Number in Chinese</title>
    <url>/2019/10/17/PTA1082-Read-Number-in-Chinese/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai.</p><a id="more"></a>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-123456789</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100800</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yi Shi Wan ling ba Bai</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>可以按每四位来组织数字段，每个数字段有一个后缀，比如1-4位后缀为“”，5-8位后缀为“Wan”，9位后缀为“Yi”，每个数字段单独组织语言，如果数字段不全为0则加上相应后缀。每个数字段负责构造一个堆栈，栈顶为高位数字的对应字符串。、</p>
<p>0的处理：0的出现有以下几种情况</p>
<ul>
<li>高位0，比如0123，在栈顶加“ling”。</li>
<li>中间0，比如1203，在栈的中间位置加“ling”。</li>
<li>低位0，比如1230，不加。</li>
<li>全0，堆栈只有一个元素“ling”。</li>
</ul>
<p>将几个数字段的堆栈拼接为一个堆栈，栈顶为高位数字。<br>注意，还要对0进行后处理，因为之前对全0的处理方式会导致下面几个问题：</p>
<ul>
<li>0重复，比如1-0000-0100</li>
<li>出现低位上0，比如1000-0000</li>
</ul>
<p>因此，最后还要去除堆栈中重复的零，和栈底的零；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (first) first = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> num;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ds&#123; <span class="string">"ling"</span>,<span class="string">"yi"</span>,<span class="string">"er"</span>,<span class="string">"san"</span>,<span class="string">"si"</span>,<span class="string">"wu"</span>,<span class="string">"liu"</span>,<span class="string">"qi"</span>,<span class="string">"ba"</span>,<span class="string">"jiu"</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name1&#123;<span class="string">""</span>, <span class="string">" Shi"</span>,<span class="string">" Bai"</span>,<span class="string">" Qian"</span> &#125;; </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name2&#123;<span class="string">""</span>, <span class="string">" Wan"</span>,<span class="string">" Yi"</span> &#125;;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">stack</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="string">"0"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ling"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">		print(<span class="string">"Fu"</span>);</span><br><span class="line">		num.erase(num.begin());</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(num.begin(), num.end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size()/<span class="number">4</span>+(num.size()%<span class="number">4</span>?<span class="number">1</span>:<span class="number">0</span>); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">4</span>; j &lt; num.size() &amp;&amp; j &lt; (i + <span class="number">1</span>) * <span class="number">4</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">string</span> temp;</span><br><span class="line">			<span class="keyword">if</span> (num[j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">stack</span>[i].empty() &amp;&amp; <span class="built_in">stack</span>[i].back() != <span class="string">"ling"</span> &amp;&amp; <span class="built_in">stack</span>[i].back() != <span class="string">"Wan"</span>) <span class="built_in">stack</span>[i].push_back(<span class="string">"ling"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp += ds[num[j] - <span class="string">'0'</span>];</span><br><span class="line">			temp += name1[j % <span class="number">4</span>];</span><br><span class="line">			<span class="built_in">stack</span>[i].push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果全零</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">stack</span>.empty()) <span class="built_in">stack</span>[i].push_back(<span class="string">"ling"</span>);</span><br><span class="line">		<span class="comment">//不全零，则在栈底加上后缀</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">stack</span>[i].front() += name2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		s.insert(s.end(),<span class="built_in">stack</span>[i].begin(), <span class="built_in">stack</span>[i].end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it &lt; s.end() - <span class="number">1</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">"ling"</span> &amp;&amp; *(it + <span class="number">1</span>) == <span class="string">"ling"</span>) it = s.erase(it);</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it &lt; s.end();) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">"ling"</span>) it = s.erase(it);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">		print(s.back());</span><br><span class="line">		s.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较简洁，并且可拓展性比较强，当题目的位数限制提高后也能适用</p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1074 反转链表</title>
    <url>/2019/10/14/PTA1074-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<h2 id="解题关键"><a href="#解题关键" class="headerlink" title="解题关键"></a>解题关键</h2><p>用哈希表存储链表，在链表头需要另外插入一个空节点指向原链表头。<br>反转的迭代中需要三个临时指针，分别指向被反转节点及其之前、之后的位置。注意逆转节点段头尾的处理。注意链表尾边界情况的处理。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> key=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> val; </span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; ahash(<span class="number">100001</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root, n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; root &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> temp1, temp2, temp3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temp1 &gt;&gt; temp2 &gt;&gt; temp3;</span><br><span class="line">		ahash[temp1] = Node(&#123; temp1,temp2,temp3 &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	ahash[<span class="number">100000</span>].next = root;</span><br><span class="line">	<span class="keyword">int</span> it, preit, postit; <span class="comment">//分别指向节点段的末尾，节点段之前，节点段之后</span></span><br><span class="line">	it = root;</span><br><span class="line">	preit = <span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (it != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count != k) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			it = ahash[it].next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			postit = ahash[it].next;</span><br><span class="line">			<span class="keyword">int</span> tempit= ahash[preit].next;</span><br><span class="line">			<span class="keyword">int</span> tempit_ = ahash[tempit].next;</span><br><span class="line">			<span class="keyword">int</span> tempit__ = ahash[tempit_].next;</span><br><span class="line">			<span class="keyword">while</span>(tempit != it) &#123;</span><br><span class="line">				ahash[tempit_].next = tempit;</span><br><span class="line">				tempit = tempit_;</span><br><span class="line">				tempit_ = tempit__;</span><br><span class="line">				<span class="comment">//注意处理边界情况</span></span><br><span class="line">				<span class="keyword">if</span> (tempit__ != <span class="number">-1</span>)</span><br><span class="line">					tempit__ = ahash[tempit__].next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> newpre = ahash[preit].next;</span><br><span class="line">			ahash[newpre].next = postit;</span><br><span class="line">			ahash[preit].next = it;</span><br><span class="line"></span><br><span class="line">			preit = newpre;</span><br><span class="line">			it = postit;</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ahash[<span class="number">100000</span>].next; i != <span class="number">-1</span>; i = ahash[i].next) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ahash[i].next == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>, ahash[i].key, ahash[i].val);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, ahash[i].key, ahash[i].val, ahash[i].next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1038 数字段排序</title>
    <url>/2019/10/14/PTA1038-%E6%95%B0%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//核心，判断哪个数字段排前面的算法</span></span><br><span class="line"><span class="comment">//局部规划+贪婪？，本质上就是先乱序建立好一个数字段，</span></span><br><span class="line"><span class="comment">//交换两个数字段，如果交换后有提升，则采纳；如果无提升，就不采纳</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lhs, <span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> temp1 = lhs + rhs;</span><br><span class="line">	<span class="built_in">string</span> temp2 = rhs + lhs;</span><br><span class="line">	<span class="keyword">if</span> (temp1 &lt; temp2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (temp1 == temp2 &amp;&amp; temp1.size() &lt; temp2.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nums;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">string</span> temp;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">		nums.push_back(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(nums.begin(), nums.end(),cmp);</span><br><span class="line">	<span class="built_in">string</span> result;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">		result += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输入参数全0的情况</span></span><br><span class="line">	<span class="keyword">int</span> off = result.find_first_not_of(<span class="string">'0'</span>);</span><br><span class="line">	<span class="keyword">if</span> (off == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; result.substr(off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/14/myFirstTry/</url>
    <content><![CDATA[<h1 id="Winger强势入场"><a href="#Winger强势入场" class="headerlink" title="Winger强势入场"></a>Winger强势入场</h1><p>2019-10-14 经历了各种艰难，这个博客走起来了</p>
<img src="/2019/10/14/myFirstTry/1.jpg" title="走起！">]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
</search>
