<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows下的C++ Socket编程</title>
    <url>/2019/11/12/Windows%E4%B8%8B%E7%9A%84C-Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Socket（套接字）"><a href="#Socket（套接字）" class="headerlink" title="Socket（套接字）"></a>Socket（套接字）</h2><p>套接字是计算机进程与网络之间的一个接口，准确地说，是应用层与运输层之间的接口，因此套接字也成为应用程序与网络之间的API。一个套接字是连接的一个端点，客户端与服务器端通过套接字传输数据。每个套接字由一个IP地址和端口号决定，表示为“地址：端口”。</p>
<a id="more"></a>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>本文将采用TCP协议。TCP是一个面向连接的传输层协议，每个连接由客户端和服务器端的两个套接字地址唯一决定。这要求客户和服务器在开始能够互相传输数据前，先进行三次握手，才能够创建连接。流程上讲，客户端套接字先与服务器上负责“迎接”的套接字进行接触，然后服务器端新生成一个连接套接字，与客户端套接字建立连接。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>以下是创建流式TCP/IP客户端-服务器端的通用流程。</p>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ol>
<li>Initialize Winsock.</li>
<li>Create a socket.</li>
<li>Bind the socket.</li>
<li>Listen on the socket for a client.</li>
<li>Accept a connection from a client.</li>
<li>Receive and send data.</li>
<li>Disconnect.</li>
</ol>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>Initialize Winsock.</li>
<li>Create a socket.</li>
<li>Connect to the server.</li>
<li>Send and receive data.</li>
<li>Disconnect.</li>
</ol>
<h2 id="Socket初始化"><a href="#Socket初始化" class="headerlink" title="Socket初始化"></a>Socket初始化</h2><p>以下是Windows Socket的初始化过程。<br>预处理部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br></pre></td></tr></table></figure>

<p>这是Windows Socket的API，其中stdio.h是用来引入标准输入输出函数的，例如printf()。第4行#pragma注释向链接器指示需要Ws2_32.lib文件。</p>
<p>初始化部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> iResult = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//指定Winsock版本，初始化Winsock</span></span><br><span class="line">iResult = WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WSAStartup failed: %d\n"</span>, iResult);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端-服务器端信息收发程序"><a href="#客户端-服务器端信息收发程序" class="headerlink" title="客户端-服务器端信息收发程序"></a>客户端-服务器端信息收发程序</h2><p>下面将基于一个简单的信息收发程序，简单地介绍客户端与服务器端的创建步骤。基本上基于上文中的通用流程。</p>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> DEFAULT_PORT = <span class="string">"27015"</span>; <span class="comment">//默认的服务器端端口号</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> DEFAULT_BUFLEN = <span class="number">512</span>; <span class="comment">//接收消息的缓冲大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化Winsock</span></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	<span class="keyword">int</span> iResult = <span class="number">0</span>;</span><br><span class="line">	iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WSAStartup failed: %d\n"</span>, iResult);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//获取服务器地址信息</span></span><br><span class="line">	addrinfo* result = <span class="literal">NULL</span>, * ptr = <span class="literal">NULL</span>, hints; <span class="comment">//储存地址信息的结构</span></span><br><span class="line">	ZeroMemory(&amp;hints, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">	hints.ai_family = AF_UNSPEC; <span class="comment">//不指定，可以同时兼容IPv6，IPv4</span></span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hints.ai_protocol = IPPROTO_TCP; <span class="comment">//指定TCP协议</span></span><br><span class="line">	<span class="comment">//指定服务器的地址和端口号</span></span><br><span class="line">	iResult = getaddrinfo(argv[<span class="number">1</span>], DEFAULT_PORT, &amp;hints, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"getaddrinfo failed: %d\n"</span>, iResult);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//创建连接Socket</span></span><br><span class="line">	SOCKET ConnectSocket = INVALID_SOCKET;</span><br><span class="line">	<span class="comment">//getaddrinfo返回的是一个list，对其中每一个尝试连接直到成功</span></span><br><span class="line">	<span class="keyword">for</span> (ptr = result; ptr; ptr = ptr-&gt;ai_next) &#123;</span><br><span class="line">		ConnectSocket = socket(ptr-&gt;ai_family, ptr-&gt;ai_socktype, ptr-&gt;ai_protocol);</span><br><span class="line">		<span class="keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Error at socket(): %ld\n"</span>, WSAGetLastError());</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//给定服务器端地址，建立与服务器的连接</span></span><br><span class="line">		<span class="comment">//其中客户端的IP地址与端口号会自动获取</span></span><br><span class="line">		iResult = connect(ConnectSocket, ptr-&gt;ai_addr, (<span class="keyword">int</span>)ptr-&gt;ai_addrlen);</span><br><span class="line">		<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">			closesocket(ConnectSocket);</span><br><span class="line">			ConnectSocket = INVALID_SOCKET;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	freeaddrinfo(result);</span><br><span class="line">	<span class="comment">//多次尝试后仍未成功连接</span></span><br><span class="line">	<span class="keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Unable to connect to server!\n"</span>);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//发送接收消息</span></span><br><span class="line">	<span class="keyword">char</span> sendbuf[DEFAULT_BUFLEN];</span><br><span class="line">	scanf_s(<span class="string">"%s"</span>, sendbuf);</span><br><span class="line">	<span class="keyword">char</span> recvbuf[DEFAULT_BUFLEN];</span><br><span class="line">	<span class="comment">//发送初始信息，返回值是发送的字节数</span></span><br><span class="line">	iResult = send(ConnectSocket, sendbuf, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send failed: %d\n"</span>, WSAGetLastError());</span><br><span class="line">		closesocket(ConnectSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Bytes Sent: %ld\n"</span>, iResult);</span><br><span class="line">	<span class="comment">//不再需要发送消息了，可以关闭发送的通道</span></span><br><span class="line">	iResult = shutdown(ConnectSocket, SD_SEND);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"shutdown failed: %d\n"</span>, WSAGetLastError());</span><br><span class="line">		closesocket(ConnectSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		iResult = recv(ConnectSocket, recvbuf, DEFAULT_BUFLEN, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (iResult &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Bytes received: %d\n"</span>, iResult);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Connection closed\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"recv failed: %d\n"</span>, WSAGetLastError());</span><br><span class="line">	&#125; <span class="keyword">while</span> (iResult &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	closesocket(ConnectSocket);</span><br><span class="line">	WSACleanup();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> DEFAULT_PORT = <span class="string">"27098"</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> DEFAULT_BUFLEN = <span class="number">512</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化Winsock</span></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	<span class="keyword">int</span> iResult = <span class="number">0</span>;</span><br><span class="line">	iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WSAStartup failed: %d\n"</span>, iResult);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//储存地址信息的结构</span></span><br><span class="line">	addrinfo* result = <span class="literal">NULL</span>, * ptr = <span class="literal">NULL</span>, hints;</span><br><span class="line">	ZeroMemory(&amp;hints, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">	hints.ai_family = AF_INET;</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hints.ai_protocol = IPPROTO_TCP;</span><br><span class="line">	hints.ai_flags = AI_PASSIVE; <span class="comment">//声明该socket需要被bind</span></span><br><span class="line">	<span class="comment">//如果第一个参数为NULL，则返回本机上的地址</span></span><br><span class="line">	iResult = getaddrinfo(<span class="literal">NULL</span>, DEFAULT_PORT, &amp;hints, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"getaddrinfo failed: %d\n"</span>, iResult);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//建立ListenSocket</span></span><br><span class="line">	SOCKET ListenSocket = INVALID_SOCKET;</span><br><span class="line">	ListenSocket = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);</span><br><span class="line">	<span class="keyword">if</span> (ListenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error at socket(): %ld\n"</span>, WSAGetLastError());</span><br><span class="line">		freeaddrinfo(result);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将ListenSocket绑定到本机—即服务器上的地址</span></span><br><span class="line">	<span class="comment">//sockaddr_in service;</span></span><br><span class="line">	<span class="comment">//service.sin_family = AF_INET;</span></span><br><span class="line">	<span class="comment">//service.sin_addr.s_addr = ADDR_ANY;</span></span><br><span class="line">	<span class="comment">//service.sin_port = htons(27015);</span></span><br><span class="line">	<span class="comment">//iResult = bind(ListenSocket, (SOCKADDR*)&amp; service, sizeof(service));</span></span><br><span class="line">	iResult = bind(ListenSocket, result-&gt;ai_addr, (<span class="keyword">int</span>)result-&gt;ai_addrlen);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind failed with error: %d\n"</span>, WSAGetLastError());</span><br><span class="line">		freeaddrinfo(result);</span><br><span class="line">		closesocket(ListenSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	freeaddrinfo(result);</span><br><span class="line">	<span class="comment">//指示该socket为服务器的监听套接字</span></span><br><span class="line">	iResult = listen(ListenSocket, SOMAXCONN);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Listen failed with error: %ld\n"</span>, WSAGetLastError());</span><br><span class="line">		closesocket(ListenSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//接受客户端连接</span></span><br><span class="line">	SOCKET ClientSocket;</span><br><span class="line">	<span class="comment">//accept会一直等待直到客户连接</span></span><br><span class="line">	ClientSocket = accept(ListenSocket, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ClientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"accept failed: %d\n"</span>, WSAGetLastError());</span><br><span class="line">		closesocket(ListenSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通常，服务器在接收到客户端连接之后，会把这个连接放到一个单独的线程中，但此处略去</span></span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//收发消息</span></span><br><span class="line">	<span class="keyword">char</span> recvbuf[DEFAULT_BUFLEN];</span><br><span class="line">	<span class="keyword">int</span> iSendResult;</span><br><span class="line">	<span class="keyword">int</span> recvbuflen = DEFAULT_BUFLEN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//消息接收循环</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//由于收到的消息不带有字符串终止符，因此每次都要将缓冲置全0，不然无法判断字符串终止</span></span><br><span class="line">		<span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">		<span class="comment">//recv将阻塞等待客户端消息，客户端将发送通道关闭后，recv返回0</span></span><br><span class="line">		iResult = recv(ClientSocket, recvbuf, recvbuflen, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, recvbuf);</span><br><span class="line">			<span class="comment">// Echo the buffer back to the sender</span></span><br><span class="line">			iSendResult = send(ClientSocket, recvbuf, iResult, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (iSendResult == SOCKET_ERROR) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"send failed: %d\n"</span>, WSAGetLastError());</span><br><span class="line">				closesocket(ClientSocket);</span><br><span class="line">				WSACleanup();</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Bytes sent: %d\n"</span>, iSendResult);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Connection closing...\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"recv failed: %d\n"</span>, WSAGetLastError());</span><br><span class="line">			closesocket(ClientSocket);</span><br><span class="line">			WSACleanup();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (iResult &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//-----------------------</span></span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="comment">//服务器关闭</span></span><br><span class="line">	iResult = shutdown(ClientSocket, SD_SEND);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"shutdown failed with error: %d\n"</span>, WSAGetLastError());</span><br><span class="line">		closesocket(ClientSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	closesocket(ClientSocket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>recv函数是一直阻塞的，直到对方发送消息，或者对方关闭send通道，因此连接结束后要及时释放send通道，否则一方将会一直在等待recv。</li>
<li>运行时，在参数列表中输入“localhost”代表服务器为本机。</li>
<li>在实际情况中，服务器端收到客户端连接请求后，会创建一个新的线程来处理该连接。</li>
<li>在socket编程中，每一步都要注意错误检测。</li>
<li>如果服务器要同时监听IPv4和IPv6，必须创建两个监听套接字，分别监听IPv4和IPv6。</li>
</ul>
<h3 id="一个大坑"><a href="#一个大坑" class="headerlink" title="一个大坑"></a>一个大坑</h3><p>一开始我客户端怎么都传不了信息到服务器端上，最后发现是端口不知道被什么占用了，修改默认的端口号即可。<br>怎么看端口占用呢？<br>首先进入cmd，输入“netstat -ano | findstr “:27015””，回车，其中27015是想要查询的端口号<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191113153352.png"><br>发现27015端口不知道被什么进程给占用了，并且一直在监听，其中最右边的14020是进程的ID号。<br>进入任务管理器-&gt;详细信息，看到第二列“PID”，即为进程号，按进程号即可找到占用端口的进程。<br>找到罪魁祸首了，盘他！<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191113154202.png"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>大成功！<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191113160906.gif"></p>
<blockquote>
<p>参考资料： <a href="https://docs.microsoft.com/zh-cn/windows/win32/winsock/getting-started-with-winsock" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/winsock/getting-started-with-winsock</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt+OpenGL 4. 摄像机设定旋转中心</title>
    <url>/2019/11/09/Qt-OpenGL-4-%E6%91%84%E5%83%8F%E6%9C%BA%E8%AE%BE%E5%AE%9A%E6%97%8B%E8%BD%AC%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<p>许多CAD的软件中，都有设定摄像机旋转中心的功能，今天我就来实现这一功能。</p>
<a id="more"></a>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>首先考虑一个简单的问题：要把摄像机的旋转中心设在点A处，应该怎么做？</p>
<p>思路很简单：</p>
<ol>
<li>把点A移到摄像机原点处</li>
<li>再进行视角变换，旋转变换就都是绕点A的了。</li>
</ol>
<p>转换成OpenGL摄像机矩阵的代码就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMatrix4x4 CADCamera::getViewMatrix()&#123;</span><br><span class="line">    QMatrix4x4 viewMat;</span><br><span class="line">    viewMat.lookAt(Position,Position+Front,Up);</span><br><span class="line">    viewMat.translate(-rotateCenter);</span><br><span class="line">    <span class="keyword">return</span> viewMat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取摄像机原本的lookat矩阵，然后在其<strong>左边</strong>乘上一个平移矩阵，该矩阵将旋转中心的坐标移到原点处。用公式表达就是：<br><code>viewMatrix = lookAt * translateMatrix</code></p>
<p>这里再加上一个参数：translate向量。该向量是一个二维向量，之前用在摄像机的平移中。translate.x()为正代表画面向右平移，为负代表画面向左平移，y方向同理。加上translate的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMatrix4x4 CADCamera::getViewMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//摄像机平移后的坐标</span></span><br><span class="line">    QVector3D transPos=-translate.x()*Right - translate.y()*Up + Position;</span><br><span class="line">    QMatrix4x4 viewMat;</span><br><span class="line">    viewMat.lookAt(transPos,transPos+Front,Up);</span><br><span class="line">    viewMat.translate(-rotateCenter);</span><br><span class="line">    <span class="keyword">return</span> viewMat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在后面设定旋转中心的过程中，也要用到translate向量。</p>
<h2 id="设定前后画面衔接"><a href="#设定前后画面衔接" class="headerlink" title="设定前后画面衔接"></a>设定前后画面衔接</h2><p>经过处理的摄像机矩阵已经能以设定点为中心旋转了。但还有个关键问题，我们进行了一个平移操作，这个操作会改变物体在摄像机中的位置，导致前后画面会出现一个突变。在我们的设想中，设定旋转中心不会对画面造成影响，因此需要进一步的衔接。</p>
<p>我们先不妨假设在设定前，摄像机的视野中心即为原先的旋转中心（称为O1）。而设定旋转中心后，新旋转中心（称为O2）被平移矩阵移到原点处，而O1也进行了相应的平移。我们要做的就是将点O1仍置于摄像机的视野中心。<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191109224001.png"><br>一个很直观方法是将摄像机从原位置1直接平移到位置3处（如红线所示），即平移摄像机的位置变量Position，而不改变其他变量。这个方法确实可行，也比较简单，但我个人不大喜欢，因为这样就让摄像机在旋转时不是看向原点的，略有些怪异。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CADCamera::setCenter(QVector3D pos)</span><br><span class="line">&#123;</span><br><span class="line">    QVector3D centerTrans=pos-rotateCenter;</span><br><span class="line">    rotateCenter=pos;</span><br><span class="line">    Position-=centerTrans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法如蓝线所示，先延Front向量的方向平移摄像机（1-2），平移后，摄像机的中心仍看向原点；之后再调整translate参数，来使摄像机“看似”位于位置3处。这个相机位置+偏移量的形式可以让相机在旋转时总是看向原点，即相机的Front向量总是等于-Position。最后再通过加偏移量来平移画面。</p>
<p>实现过程如下：</p>
<ol>
<li>我们称旋转中心的平移向量为V，首先将摄像机向前平移V点乘Front的距离</li>
<li>计算摄像机水平方向的偏移，将translate向量的x分量加上V点乘Right的值</li>
<li>计算摄像机垂直方向的偏移，将translate向量的y分量加上V点乘Up的值</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CADCamera::setCenter(QVector3D pos)</span><br><span class="line">&#123;</span><br><span class="line">    QVector3D centerTrans=pos-rotateCenter;</span><br><span class="line">    rotateCenter=pos;</span><br><span class="line">    Position-=QVector3D::dotProduct(centerTrans,Front)*Front;</span><br><span class="line">    translate[0]+=QVector3D::dotProduct(Right,centerTrans);</span><br><span class="line">    translate[1]+=QVector3D::dotProduct(Up,centerTrans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了旋转中心的设定，至于用哪个方法，看个人喜好吧。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>由于还没写点选的功能，所以只能手动输旋转中心啦。<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191113162239.gif" width="70%"></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>OpenGL</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客时的浏览器缓存问题</title>
    <url>/2019/11/05/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Google浏览器缓存真的是个大坑，当在后台更新了网页的内容，但打开网页一看还跟原来一毛一样，这种无妄之灾会对人的心理造成很大的伤害。下面是几种解决方法：</p>
<a id="more"></a>
<h2 id="一、设置浏览器不缓存"><a href="#一、设置浏览器不缓存" class="headerlink" title="一、设置浏览器不缓存"></a>一、设置浏览器不缓存</h2><p>方法1. Google浏览器中，F12打开控制台—&gt;Network—-&gt;Disable cache 打钩<br>方法2. 在浏览器按F12—&gt;在按下F1—&gt;找到network —-&gt; Disable cache（while DevTools is open） 打钩</p>
<h2 id="二、清空缓存"><a href="#二、清空缓存" class="headerlink" title="二、清空缓存"></a>二、清空缓存</h2><p>ctrl+shift+delete  —-&gt; 清除浏览数据</p>
<h2 id="三、强制刷新"><a href="#三、强制刷新" class="headerlink" title="三、强制刷新"></a>三、强制刷新</h2><p>ctrl + F5强制刷新</p>
<h2 id="客户端缓存问题"><a href="#客户端缓存问题" class="headerlink" title="客户端缓存问题"></a>客户端缓存问题</h2><p>以上方法都是从网站开发者的角度解决的，但网站的访客并不懂这么多，下面讲讲怎么让客户端的浏览器不储存网页缓存。<br>有两种方法：</p>
<ol>
<li>在请求头上使用Cache-Control: no-cache，可以让浏览器不缓存页面信息，但如果对于firefox，要使用Cache-Control: no-cache, no-store。</li>
<li>把请求头上的Last-Modified时间总是改为当前时间，浏览器就会认为网页被修改了。从而更新缓存。</li>
</ol>
<p>两种方法还没有在hexo博客上进行实践过，应该用一个js脚本就可以做到吧。</p>
<blockquote>
<p>参考资料：<a href="https://my.oschina.net/zimingforever/blog/134914?fromerr=5ygd55ZT" target="_blank" rel="noopener">https://my.oschina.net/zimingforever/blog/134914?fromerr=5ygd55ZT</a><br><a href="http://blog.httpwatch.com/2007/12/10/two-simple-rules-for-http-caching/" target="_blank" rel="noopener">http://blog.httpwatch.com/2007/12/10/two-simple-rules-for-http-caching/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt+OpenGL 3.类体系优化</title>
    <url>/2019/10/27/Qt-OpenGL-3-%E7%B1%BB%E4%BD%93%E7%B3%BB%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>由于是初次尝试面向对象的编程，觉得之前搭建的结构有诸多不妥之处。因此进行一次整理优化。</p>
<blockquote>
<p>除非程序员做功，否则代码总是朝着熵增的方向进行——热力学第四定律</p>
</blockquote>
<a id="more"></a>
<h2 id="着色器类"><a href="#着色器类" class="headerlink" title="着色器类"></a>着色器类</h2><p>在之前的代码中，初始化着色器、管理着色器的任务是交给glwidget类的，感觉不是非常合理。因为一种模型类只对应于一种着色器，两者之间是紧耦合的，应该由模型负责管理自己的着色器。</p>
<p>另一方面，多个模型类的实例可能使用同一种着色器，为每个实例分配一个着色器对象可能比较浪费，也不便于着色器的统一管理。因此我使用设计模式中的单例模式(Singleton Method），建立一个着色器的单体类。</p>
<p>首先是一个标准的单体类模板，通过将构造函数声明为protected的，防止单体类被外部初始化，而静态成员变量ms_Singleton指向该单体类的唯一实例。GetSingleton()以及GetSingletonPtr()函数是访问该实例的唯一接口。该实例在第一次访问时被创建。</p>
<figure class="highlight cpp"><figcaption><span>singleton.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">static</span> T* ms_Singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Singleton( <span class="keyword">void</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        assert( !ms_Singleton );</span><br><span class="line">        ms_Singleton = <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Singleton( <span class="keyword">void</span> )</span><br><span class="line">    &#123;  assert( ms_Singleton );  ms_Singleton = <span class="number">0</span>;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">GetSingleton</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> *(GetSingletonPtr());  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">GetSingletonPtr</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ms_Singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            ms_Singleton = <span class="keyword">new</span> T();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ms_Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span>* <span class="title">Singleton</span>&lt;T&gt;:</span>:ms_Singleton = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SINGLETON_H</span></span></span><br></pre></td></tr></table></figure>

<p>之后，创建一个着色器类，并令其继承单体模板类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLShader</span>:</span>Singleton&lt;GLShader&gt;</span><br></pre></td></tr></table></figure>

<p>将本来在GLWidget类中的着色器对象，交由着色器类管理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//着色器列表</span></span><br><span class="line">    QOpenGLShaderProgram shader;</span><br><span class="line">    QOpenGLShaderProgram CADshader;</span><br></pre></td></tr></table></figure>

<p>本来在GLWidgetTools命名空间中的着色器初始化函数initShader()，也要移植到GLShader类中。总的代码如下：</p>
<figure class="highlight cpp"><figcaption><span>glshader.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GLSHADER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLSHADER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleton.h"</span></span></span><br><span class="line"><span class="comment">//统一管理所有shader</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLShader</span>:</span>Singleton&lt;GLShader&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> GLShader&amp; <span class="title">GetSingleton</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> GLShader* <span class="title">GetSingletonPtr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    GLShader();</span><br><span class="line">    ~GLShader();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//着色器列表</span></span><br><span class="line">    QOpenGLShaderProgram shader;</span><br><span class="line">    QOpenGLShaderProgram CADshader;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initShader</span><span class="params">(QOpenGLShaderProgram *shader, QString vs, QString fs, QString gs=<span class="string">""</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GLSHADER_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>glshader.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glshader.h"</span></span></span><br><span class="line"></span><br><span class="line">GLShader &amp;GLShader::GetSingleton()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Singleton&lt;GLShader&gt;::GetSingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLShader *GLShader::GetSingletonPtr()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Singleton&lt;GLShader&gt;::GetSingletonPtr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLShader::GLShader()</span><br><span class="line">&#123;</span><br><span class="line">    initShader(&amp;shader,<span class="string">":/shader/shader.vs"</span>,<span class="string">":/shader/shader.fs"</span>);</span><br><span class="line">    initShader(&amp;CADshader,<span class="string">":/shader/CADshader.vs"</span>,<span class="string">":/shader/CADshader.fs"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载shader文件</span></span><br><span class="line"><span class="keyword">void</span> GLShader::initShader(QOpenGLShaderProgram *shader, QString vs, QString fs, QString gs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Vertex, vs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(gs!=<span class="string">""</span>&amp;&amp;!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Geometry, gs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Fragment, fs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;link())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;bind())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shader-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将着色器交给模型类"><a href="#将着色器交给模型类" class="headerlink" title="将着色器交给模型类"></a>将着色器交给模型类</h2><p>第二步是将着色器从GLWidget类中转移到GLModel类中。首先在GLModel类内创建一个指向着色器的指针，之后要在模型初始化过程中获取着色器对象。同样，此处采用了工厂模式，子类可以方便地改变着色器类型。另外，为了给在运行期间内更换着色器留出接口，创建了setShader()成员函数。</p>
<p>工厂函数在初始化函数setupModel()中调用，默认返回指向最简略的shader的指针。而在CADShader类中，重写了着色器工厂函数，返回指向CADshader的指针。</p>
<figure class="highlight cpp"><figcaption><span>openglmodel.h</span></figcaption><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLModel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setShader</span><span class="params">(QOpenGLShaderProgram* s)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//着色器工厂</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QOpenGLShaderProgram* <span class="title">shaderFactory</span><span class="params">()</span></span>;</span><br><span class="line">    QOpenGLShaderProgram* shader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CADModel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QOpenGLShaderProgram* <span class="title">shaderFactory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>openglmodel.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">void</span> GLModel::setShader(QOpenGLShaderProgram *s)</span><br><span class="line">&#123;</span><br><span class="line">    shader=s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> GLModel::setupModel()</span><br><span class="line">&#123;</span><br><span class="line">    shader=shaderFactory();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//着色器工厂函数</span></span><br><span class="line">QOpenGLShaderProgram *GLModel::shaderFactory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;GLShader::GetSingletonPtr()-&gt;shader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QOpenGLShaderProgram *CADModel::shaderFactory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;GLShader::GetSingletonPtr()-&gt;CADshader;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然，在GLWidget类中，将着色器相关内容移除了。</p>
<h2 id="抽象模型类"><a href="#抽象模型类" class="headerlink" title="抽象模型类"></a>抽象模型类</h2><p>考虑到之后可能会有各种模型需要绘制，并且需要对模型进行一个层次化的管理。于是考虑使用设计方法中的Composite模式，将模型组织成树状结构。</p>
<center>
<img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/dc44745eb8f7e756bf2dd9eb63d6a681_20191105202100.png" width="50%"><br>
<div>Composite模式的类图[GoF]</div>
</center>
首先，要将之前的GLModel类向上抽象一层，形成一个抽象的Model类，对应类图中的Component类。然后要派生出一个CompositeModel类，进行模型的管理与组织。
<figure class="highlight cpp"><figcaption><span>openglmodel.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractModel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AbstractModel(GLWidget* f);</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractModel()=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setupModel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCamera</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AbstractCamera&gt; c)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AbstractCamera&gt; myCamera;</span><br><span class="line">    GLWidget* father;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeModel</span>:</span><span class="keyword">public</span> AbstractModel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CompositeModel(GLWidget* f):AbstractModel(f)&#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~CompositeModel();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AbstractModel&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChile</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AbstractModel&gt;&gt; children;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>openglmodel.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">AbstractModel::~AbstractModel()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> AbstractModel::Draw()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">AbstractModel::AbstractModel(GLWidget *f)</span><br><span class="line">    :father(f)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> AbstractModel::setupModel()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> AbstractModel::setCamera(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AbstractCamera&gt; c)</span><br><span class="line">&#123;</span><br><span class="line">    myCamera=c;</span><br><span class="line">&#125;</span><br><span class="line">CompositeModel::~CompositeModel()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CompositeModel::Draw()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//绘制所有子模型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;model:children)&#123;</span><br><span class="line">        model-&gt;Draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CompositeModel::addChild(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AbstractModel&gt; c)</span><br><span class="line">&#123;</span><br><span class="line">    children.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CompositeModel::removeChile()</span><br><span class="line">&#123;</span><br><span class="line">    children.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后如果要将模型以不同的类别进行管理，则可以利用CompositeModel类派生出有具体管理功能的类。</p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>OpenGL</tag>
        <tag>图形学</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt+OpenGL 2.创建摄像机类</title>
    <url>/2019/10/25/Qt-OpenGL-%E5%88%9B%E5%BB%BA%E6%91%84%E5%83%8F%E6%9C%BA%E7%B1%BB/</url>
    <content><![CDATA[<p>  上一篇文章中，我在Qt中搭建了一个Opengl绘制框架，并绘制了一个三角形，为了让朴实无华且枯燥的三角形动起来，我决定创建一个摄像机。</p>
<a id="more"></a>
<h2 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h2><p>我创建了一个openglcamera.h文件，以及对应的cpp文件，用于安放摄像机类体系。什么，类体系?没错，我先创建了一个摄像机的抽象基类，称为AbstractCamera，并由此派生出其余的具体摄像机类。学c++，还是要多锻炼自己面向对象的思想。</p>
<p>首先要为摄像机类定义抽象接口，摄像机类公有的功能，一是要获取矩阵，二是要处理外界事件，比如按键、鼠标移动等。因此我在抽象类中声明了以下几个纯虚函数：</p>
<ul>
<li>virtual QMatrix4x4 getViewMatrix() 获取视图矩阵</li>
<li>virtual QMatrix4x4 getProjectMatrix() 获取投影矩阵</li>
<li>virtual void processEvent(Camera::Event e) 处理事件</li>
<li>virtual void processEvent(Camera::Event e,float xoffset) 重载函数，处理滚轮等事件</li>
<li>virtual void processEvent(Camera::Event e,float xoffset,float yoffset) 重载函数，处理鼠标移动等事件 </li>
</ul>
<p>其中对于processEvent()函数我重载了多个版本，因为对于不同的事件可能有不同的参数传递，比如鼠标移动事件就需要相对移动坐标参数。本来我想用可变长参数列表实现，但考虑到会使接口不是特别清晰，于是采用了重载的方法。</p>
<p>为了将三角形动起来，我通过上面定义的抽象摄像机，派生出一个CAD风格的摄像机类，命名为CADCamera。该类中有一些独有的成员变量，zoomSensitivity、rotateSensitivity等，用来控制摄像机的各项属性；最核心的旋转和缩放算法在processEvent()函数中，作者并不打算展开描述这些细节╮(╯3╰)╭；最后获取投影矩阵和视图矩阵则分别用到了Qt矩阵库中的QMatrix4x4::ortho()、QMatrix4x4::lookAt()函数（投影矩阵采用正投影）。</p>
<p>以下是代码：</p>
<figure class="highlight cpp"><figcaption><span>openglcamera.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OPENGLCAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPENGLCAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMatrix4x4&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span>;</span></span><br><span class="line"><span class="keyword">namespace</span> Camera&#123;</span><br><span class="line">    <span class="comment">//各种外界事件</span></span><br><span class="line">    <span class="keyword">enum</span> Event&#123;Up,Down,Left,Right,Mouse_Move,Mouse_Scroll&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个抽象的摄像机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCamera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AbstractCamera()=<span class="keyword">default</span>;s</span><br><span class="line">    AbstractCamera(GLWidget* father,QVector3D pos,QVector3D front,QVector3D up);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getProjectMatrix</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理所有响应类事件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//滚轮、鼠标移动之类的事件，需要位移参数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset,<span class="keyword">float</span> yoffset)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//基类的析构函数也要设成虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractCamera();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    GLWidget* father;</span><br><span class="line">    QVector3D Position;</span><br><span class="line">    QVector3D Front;</span><br><span class="line">    QVector3D Up;</span><br><span class="line">    QVector3D Right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CADCamera</span>:</span> <span class="keyword">public</span> AbstractCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CADCamera(GLWidget* father,QVector3D pos);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getViewMatrix</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QMatrix4x4 <span class="title">getProjectMatrix</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Camera::Event e,<span class="keyword">float</span> xoffset,<span class="keyword">float</span> yoffset)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseScroll</span><span class="params">(<span class="keyword">float</span> yoffset)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(<span class="keyword">float</span> xoffset, <span class="keyword">float</span> yoffset)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> zoomSensitivity;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> rotateSensitivity;</span><br><span class="line">    <span class="comment">//正交投影矩阵的基础宽度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> orthoWidth;</span><br><span class="line">    <span class="comment">//缩放比</span></span><br><span class="line">    <span class="keyword">float</span> Zoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OPENGLCAMERA_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>openglcamera.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglcamera.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTransform&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMatrix4x4&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line">AbstractCamera::AbstractCamera(GLWidget* father,QVector3D pos, QVector3D front, QVector3D up):</span><br><span class="line">    father(father),Position(pos),Front(front),Up(up)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前方向向量和上方向向量叉乘决定右方向向量</span></span><br><span class="line">    Right = QVector3D::crossProduct(front,up);</span><br><span class="line">    Right.normalize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractCamera::~AbstractCamera()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CADCamera::CADCamera(GLWidget* father,QVector3D pos):</span><br><span class="line">    AbstractCamera (father,pos,QVector3D(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>),QVector3D(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0f</span>)),</span><br><span class="line">    zoomSensitivity(<span class="number">0.001</span>),rotateSensitivity(<span class="number">0.3</span>),orthoWidth(<span class="number">2.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Zoom = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QMatrix4x4 CADCamera::getViewMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    QMatrix4x4 viewMat;</span><br><span class="line">    viewMat.lookAt(Position,Position+Front,Up);</span><br><span class="line">    <span class="keyword">return</span> viewMat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QMatrix4x4 CADCamera::getProjectMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    QMatrix4x4 projectMat;</span><br><span class="line">    <span class="keyword">float</span> halfWid = orthoWidth*Zoom/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//opengl界面的高宽比</span></span><br><span class="line">    <span class="keyword">float</span> hw = father-&gt;height()*<span class="number">1.0</span>/father-&gt;width();</span><br><span class="line">    <span class="comment">//远平面和近平面的坐标看情况可以适当调大</span></span><br><span class="line">    projectMat.ortho(-halfWid,halfWid,-halfWid*hw,halfWid*hw,<span class="number">100.0f</span>,<span class="number">-100.0f</span>);</span><br><span class="line">    <span class="keyword">return</span> projectMat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::processEvent(Camera::Event e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::processEvent(Camera::Event e, <span class="keyword">float</span> xoffset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Camera;</span><br><span class="line">    <span class="keyword">switch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">case</span> Mouse_Scroll: ProcessMouseScroll(xoffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::processEvent(Camera::Event e, <span class="keyword">float</span> xoffset, <span class="keyword">float</span> yoffset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Camera;</span><br><span class="line">    <span class="keyword">switch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">case</span> Mouse_Move: ProcessMouseMovement(xoffset,yoffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::ProcessMouseScroll(<span class="keyword">float</span> yoffset)</span><br><span class="line">&#123;</span><br><span class="line">    Zoom -= yoffset*zoomSensitivity;</span><br><span class="line">    <span class="keyword">if</span>(Zoom&lt;=<span class="number">0.01</span>)</span><br><span class="line">        Zoom = <span class="number">0.01</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CADCamera::ProcessMouseMovement(<span class="keyword">float</span> xoffset, <span class="keyword">float</span> yoffset)</span><br><span class="line">&#123;</span><br><span class="line">    xoffset *= rotateSensitivity;</span><br><span class="line">    yoffset *= rotateSensitivity;</span><br><span class="line"></span><br><span class="line">    QMatrix4x4 rotateX;</span><br><span class="line">    rotateX.rotate(xoffset,Up);</span><br><span class="line">    QMatrix4x4 rotateY;</span><br><span class="line">    rotateY.rotate(yoffset,Right);</span><br><span class="line">    Up = QVector3D(rotateY*QVector4D(Up,<span class="number">1.0</span>));</span><br><span class="line">    Position = QVector3D(rotateX*rotateY*QVector4D(Position,<span class="number">1.0</span>));</span><br><span class="line">    Front = -Position;</span><br><span class="line">    Front.normalize();</span><br><span class="line">    Right = QVector3D::crossProduct(Front,Up);</span><br><span class="line">    Right.normalize();</span><br><span class="line">    <span class="comment">//上述计算后Up会有微小误差，会形成累积误差，要修正Up，使三个方向向量保持90度关系</span></span><br><span class="line">    Up = -QVector3D::crossProduct(Front,Right);</span><br><span class="line">    Up.normalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新的着色器"><a href="#新的着色器" class="headerlink" title="新的着色器"></a>新的着色器</h2><p>由于加入了模型、视图、投影矩阵，所以需要新的顶点着色器。为每个矩阵设一个uniform变量，并乘到原始坐标上。</p>
<figure class="highlight cpp"><figcaption><span>CADshader.vs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 project;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = project*view*model*vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，为了给这个三角形一点颜色看看（give this triangel a little color see see），我在片段着色器中加入了代表颜色的uniform变量。</p>
<figure class="highlight cpp"><figcaption><span>CADshader.fs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">uniform vec4 myColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = myColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改GLWidget类"><a href="#修改GLWidget类" class="headerlink" title="修改GLWidget类"></a>修改GLWidget类</h2><p>为了适应新加入的摄像机类，GLWidget类中需要做一些修改。第一步是加入一个摄像机的成员变量，这里需要做一点手脚。不能直接为该摄像机变量声明成具体的CADCamera类，因为如果以后有更多的摄像机类了（如果有那一天的话），GLWidget的子类可能会需要另一个摄像机类，这样就需要为摄像机对象的类型留出更改空间。这里就要祭出工厂模式啦（Factory Method），在头文件中定义一个工厂虚函数，和一个指向抽象摄像机类的智能指针成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractCamera* <span class="title">cameraFactory</span><span class="params">()</span></span>; <span class="comment">//“摄像机工厂”</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;AbstractCamera&gt; pCamera;</span><br></pre></td></tr></table></figure>

<p>源文件中实现该工厂函数，在该版本的GLWidget中，工厂建立一个CADCamera对象，并以注意：工厂函数不能在GLWidget构造函数中调用，因为GLWiget的派生类在构造GLWiget类时，派生类本身没有构造完毕，因此调用的永远是GLWiget版本的cameraFactory()。</p>
<blockquote>
<p>绝不在构造和析构函数中调用virtual函数——《effective c++》</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbstractCamera *GLWidget::cameraFactory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CADCamera(<span class="keyword">this</span>,QVector3D(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">3.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在初始化函数中调用工厂函数</span></span><br><span class="line">GLWidget::GLWidget(QWidget *parent) : QOpenGLWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    father = parent;</span><br><span class="line">    pCamera.reset(cameraFactory());</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加新模型类"><a href="#增加新模型类" class="headerlink" title="增加新模型类"></a>增加新模型类</h2><p>为了迎合该摄像机，需要派生出一种新的CADModel类，类定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CADModel</span>:</span><span class="keyword">public</span> GLModel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CADModel(GLWidget* f)</span><br><span class="line">        :GLModel(f)&#123;&#125;;</span><br><span class="line">    CADModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;())</span><br><span class="line">        :GLModel(f,v,i,t)&#123;&#125;;</span><br><span class="line">    CADModel(GLWidget* f,<span class="keyword">unsigned</span> <span class="keyword">int</span> vbo,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;())</span><br><span class="line">        :GLModel(f,vbo,i,t)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mainDraw</span><span class="params">(QOpenGLShaderProgram* shader)</span> override</span>;</span><br><span class="line">    QMatrix4x4 modelMat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该类重写mainDraw()函数，在其中分配矩阵和颜色的Uniform，因为模型本身不做变换，模型矩阵即为单位矩阵。颜色上，使之随时间变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CADModel::mainDraw(QOpenGLShaderProgram *shader)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">float</span> t=clock()/<span class="number">200.0</span>;</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"model"</span>,modelMat);</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"view"</span>,myCamera-&gt;getViewMatrix());</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"project"</span>,myCamera-&gt;getProjectMatrix());</span><br><span class="line">    shader-&gt;setUniformValue(<span class="string">"myColor"</span>,QVector4D(<span class="built_in">sin</span>(t)/<span class="number">2</span>+<span class="number">1</span>,<span class="built_in">cos</span>(<span class="built_in">sqrt</span>(<span class="number">2</span>)*t)/<span class="number">2</span>+<span class="number">1</span>,<span class="built_in">sin</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>)*t+<span class="number">0.5</span>)/<span class="number">2</span>+<span class="number">1</span>,<span class="built_in">cos</span>(<span class="built_in">sqrt</span>(<span class="number">4</span>)*t+<span class="number">0.6</span>)/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">    father-&gt;glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>魔幻三角！<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191113161748.gif"></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>OpenGL</tag>
        <tag>图形学</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt+OpenGL 1.基本绘制框架搭建</title>
    <url>/2019/10/25/Qt-OpenGL-%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%88%B6%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>每次建立新的OpenGL工程，都要翻翻笔记，做一些复制粘贴的工作，非常朴实无华且枯燥。于是我便产生了搭建一个比较通用的OpenGL模板的想法。最近又在学习Qt和设计模式，顺便将OpenGL与Qt相结合，并亲手实践一些设计模式，权当练手罢。</p><a id="more"></a>
<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><p>我首先新建立了一个Qt的工程，并且按下图建立工程目录。其中mainwindow就是应用的主窗口，glwidget.cpp文件定义了GLWidget类，openglmodel文件中定义了被绘制的模型类。我还新建了一个资源文件目录，用来存放各种着色器文件。<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025003743.png" alt></p>
<h2 id="GLWidget类"><a href="#GLWidget类" class="headerlink" title="GLWidget类"></a>GLWidget类</h2><p>GLWidget类是opengl的绘制对象，负责所有模型、着色器、用户交互。继承QOpenGLWidget类，并重写其中的initializeGL(),paintGL(),resizeGL()虚函数，其分别对应初始化、绘制、窗体大小改变时会触发的回调函数。重写后的initializeGL主要负责一些opengl绘制环境初始化、着色器初始化、模型初始化的工作，而paintGL则相当于原生opengl中的绘制循环。</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul>
<li>opengl初始化工作要在initializeGL()中进行，而不是构造函数中，并且记得调用initializeOpenGLFunctions。</li>
<li>我通过public继承了QOpenGLFunctions_4_3_Core类（可以换成其他版本）来调用opengl的函数，有些教程，包括官方文档上使用的是protected继承，但由于我要从模型类调用GLWidget类的opengl函数，所以改成了public继承，可能会导致一些封装性上的问题。</li>
<li>我将着色器初始化工具函数initShader()放在了命名空间GLWidgetTools类中，因为该函数仅仅为了方便操作，与类本身的关系并不大。为了加强类的封装，并减小类的职责，将该函数放在外部的命名空间内更合适。</li>
</ul>
<blockquote>
<p>宁以non-member, non-friend函数替换member函数——《effective c++, item 23》</p>
</blockquote>
<figure class="highlight cpp"><figcaption><span>glwidget.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GLWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLFunctions_4_3_Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLModel</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span> :</span> <span class="keyword">public</span> QOpenGLWidget, <span class="keyword">public</span> QOpenGLFunctions_4_3_Core</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GLWidget</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeGL</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintGL</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resizeGL</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget* father;</span><br><span class="line">    <span class="comment">//智能指针是个好习惯！</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;QOpenGLShaderProgram&gt; pShader;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;GLModel&gt; model;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GLWIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>glwidget.cpp </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglmodel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> GLWidgetTools &#123;</span><br><span class="line"><span class="comment">//加载shader文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initShader</span><span class="params">(QOpenGLShaderProgram *shader, QString vs, QString fs, QString gs=<span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Vertex, vs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(gs!=<span class="string">""</span>&amp;&amp;!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Geometry, gs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;addShaderFromSourceFile(QOpenGLShader::Fragment, fs))&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;link())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!shader-&gt;bind())&#123;</span><br><span class="line">        qDebug()&lt;&lt;shader-&gt;<span class="built_in">log</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shader-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">GLWidget::GLWidget(QWidget *parent) : QOpenGLWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    father = parent;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::initializeGL()</span><br><span class="line">&#123;</span><br><span class="line">    initializeOpenGLFunctions();</span><br><span class="line">    <span class="keyword">if</span>(father) setGeometry(<span class="number">0</span>,<span class="number">0</span>,father-&gt;width(),father-&gt;height());</span><br><span class="line">    qDebug()&lt;&lt; (<span class="keyword">const</span> <span class="keyword">char</span>*)glGetString(GL_VERSION)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//获取显卡opengl版本信息</span></span><br><span class="line">    <span class="comment">//glEnable(GL_DEPTH_TEST);</span></span><br><span class="line">    glClearColor(<span class="number">82.0</span>/<span class="number">255</span>, <span class="number">87.0</span>/<span class="number">255</span>, <span class="number">110.0</span>/<span class="number">255</span>,<span class="number">0.0</span>); <span class="comment">//设置背景色</span></span><br><span class="line">    glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    pShader.reset(<span class="keyword">new</span> QOpenGLShaderProgram);</span><br><span class="line">    <span class="comment">//shader文件用资源文件储存</span></span><br><span class="line">    GLWidgetTools::initShader(pShader.get(),<span class="string">":/shader/shader.vs"</span>,<span class="string">":/shader/shader.fs"</span>);</span><br><span class="line">    <span class="comment">//模型初始化，一个三角形</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex&gt; v(<span class="number">3</span>);</span><br><span class="line">    v[<span class="number">0</span>].Position=QVector3D(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    v[<span class="number">1</span>].Position=QVector3D(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    v[<span class="number">2</span>].Position=QVector3D(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    model.reset(<span class="keyword">new</span> GLModel(<span class="keyword">this</span>,v,i));</span><br><span class="line">    model-&gt;setupModel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::paintGL()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    glClearColor(<span class="number">82.0</span>/<span class="number">255</span>, <span class="number">87.0</span>/<span class="number">255</span>, <span class="number">110.0</span>/<span class="number">255</span>,<span class="number">0.00f</span>);</span><br><span class="line">    glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    model-&gt;Draw(pShader.get());</span><br><span class="line">    qDebug()&lt;&lt;glGetError();</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::resizeGL(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//改变窗体大小</span></span><br><span class="line">    setGeometry(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">    <span class="comment">//改变视口</span></span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLWidget::init()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="openglmodel类"><a href="#openglmodel类" class="headerlink" title="openglmodel类"></a>openglmodel类</h2><p>我主要想实现一个重用性较强的模型基类，说是模型类，其实其功能可以包含光照、摄像机矩阵等与着色器之间的交互。<br>实践了一下设计方法中的Template Method，将Draw()函数视为一个绘制的模板，在其中处理一些绘制前后的通用步骤，而核心的绘制过程则作为虚函数交给派生类重写。</p>
<h3 id="注意点：-1"><a href="#注意点：-1" class="headerlink" title="注意点："></a>注意点：</h3><ul>
<li>在头文件中使用类声明，而不是文件包含，可以减小文件之间的编译耦合</li>
<li>对于一些数据量较大的模型，顶点位置数据应该交给一个模型类来存储，而其他模型类则共享该VBO</li>
</ul>
<figure class="highlight cpp"><figcaption><span>openglmodel.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OPENGLMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPENGLMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QOpenGLShaderProgram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="comment">//在头文件中声明GLWidget类，在源文件中引入glwidget.h，减少编译耦合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLWidget</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span>;</span></span><br><span class="line"><span class="comment">//纹理类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Texture</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//顶点类</span></span><br><span class="line"><span class="comment">//结构体中内存连续存储,因此可以安心使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    QVector3D Position;</span><br><span class="line">    QVector3D Normal=QVector3D();</span><br><span class="line">    QVector2D TexCoords=QVector2D();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLModel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GLModel(GLWidget* f);</span><br><span class="line">    GLModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;());</span><br><span class="line">    <span class="comment">//当有多个对象使用同一个顶点数据时，由一个对象创建VBO，其他对象共享该VBO;</span></span><br><span class="line">    GLModel(GLWidget* f,<span class="keyword">unsigned</span> <span class="keyword">int</span> vbo,<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i=<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(),<span class="built_in">vector</span>&lt;Texture&gt; t=<span class="built_in">vector</span>&lt;Texture&gt;());</span><br><span class="line">    <span class="comment">//基类在绘制流程前后添加了一些通用步骤，子类重写绘制核心过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCamera</span><span class="params">(Camera* c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(QOpenGLShaderProgram* shader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupModel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//子类可以重写绘制的核心步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mainDraw</span><span class="params">(QOpenGLShaderProgram* shader)</span></span>;</span><br><span class="line">    GLWidget* father;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">//如果要使用纹理的话，在着色器uniform中要给纹理一个统一的编号规则</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO,VBO=<span class="number">0</span>,EBO;</span><br><span class="line">    <span class="comment">//目前来说空余的Camera对象</span></span><br><span class="line">    Camera* myCamera;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OPENGLMODEL_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>openglmodel.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglmodel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glwidget.h"</span></span></span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget *f):father(f)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget* f,<span class="built_in">vector</span>&lt;Vertex&gt; v, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i, <span class="built_in">vector</span>&lt;Texture&gt; t)</span><br><span class="line">    :father(f),vertices(v),indices(i),textures(t)&#123;&#125;</span><br><span class="line"></span><br><span class="line">GLModel::GLModel(GLWidget *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> vbo, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; i, <span class="built_in">vector</span>&lt;Texture&gt; t)</span><br><span class="line">    :VBO(vbo),indices(i),textures(t)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::setCamera(Camera *c)</span><br><span class="line">&#123;</span><br><span class="line">    myCamera=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::setupModel()</span><br><span class="line">&#123;</span><br><span class="line">    father-&gt;glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    father-&gt;glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">//如果没有从其他对象共享VBO，则创建VBO</span></span><br><span class="line">    <span class="keyword">if</span>(VBO) father-&gt;glBindBuffer(GL_ARRAY_BUFFER,VBO);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        father-&gt;glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">        father-&gt;glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">        father-&gt;glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="keyword">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 顶点法线</span></span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//offsetof可以方便地设置结构体的偏移量</span></span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, Normal));</span><br><span class="line">        <span class="comment">// 顶点纹理坐标</span></span><br><span class="line">        father-&gt;glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">        father-&gt;glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, TexCoords));</span><br><span class="line">    &#125;</span><br><span class="line">    father-&gt;glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    father-&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    father-&gt;glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>),</span><br><span class="line">                 &amp;indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    father-&gt;glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::mainDraw(QOpenGLShaderProgram *shader)</span><br><span class="line">&#123;</span><br><span class="line">    father-&gt;glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GLModel::Draw(QOpenGLShaderProgram* shader)&#123;</span><br><span class="line">    shader-&gt;bind();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">//如果没有纹理，跳过这一部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; textures.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father-&gt;glActiveTexture(GL_TEXTURE0 + i); <span class="comment">// 在绑定之前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></span><br><span class="line">        <span class="built_in">string</span> number;</span><br><span class="line">        <span class="built_in">string</span> name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">"texture_diffuse"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">"texture_specular"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(specularNr++);</span><br><span class="line"></span><br><span class="line">        shader-&gt;setUniformValue((<span class="string">"material."</span> + name + number).c_str(), i);</span><br><span class="line">        father-&gt;glBindTexture(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    father-&gt;glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    <span class="comment">// 绘制模型</span></span><br><span class="line">    father-&gt;glBindVertexArray(VAO);</span><br><span class="line">    mainDraw(shader);</span><br><span class="line">    father-&gt;glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    shader-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>最基础的shader，没啥好讲的。</p>
<figure class="highlight cpp"><figcaption><span>shader.vs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        gl_Position = vec4(aPos,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>shader.fs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 430 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        FragColor = vec4(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主窗口"><a href="#主窗口" class="headerlink" title="主窗口"></a>主窗口</h2><p>mainwindow.ui中添加OpenGL Widget控件<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025012851.png" alt><br>右键OpenGL Widget控件，提升为<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025013003.png" alt><br>在提升的类名称中填入GLWidget，头文件则为glwidget.h，点击提升，该控件就继承了我们之前编写的GLWidget类</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>当当当当~一个朴实无华且枯燥的三角形<br><img src="https://wingerzengimage.oss-cn-beijing.aliyuncs.com/img/20191025013326.png" alt></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>OpenGL</tag>
        <tag>图形学</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>1087 All Roads Lead to Rome</title>
    <url>/2019/10/20/1087-All-Roads-Lead-to-Rome/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers N (2≤N≤200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.</p><a id="more"></a>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p>
<p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1-&gt;City2-&gt;…-&gt;ROM.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 7 HZH</span><br><span class="line">ROM 100</span><br><span class="line">PKN 40</span><br><span class="line">GDN 55</span><br><span class="line">PRS 95</span><br><span class="line">BLN 80</span><br><span class="line">ROM GDN 1</span><br><span class="line">BLN ROM 1</span><br><span class="line">HZH PKN 1</span><br><span class="line">PRS ROM 2</span><br><span class="line">BLN HZH 2</span><br><span class="line">PKN GDN 1</span><br><span class="line">HZH PRS 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 195 97</span><br><span class="line">HZH-&gt;PRS-&gt;ROM</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>我与其他主要有两点不同，一是用pass number，即通过的城市个数来等价代替了average glad参数。 因为遍历的时候average glad值不好根据上一个城市来递推，但pass number值可以。</p>
<p>第二个不同是没有将相同cost的路径存到一个二维数组中再进行后处理，我直接在Dijkstra算法中判断cost, glad, pass number参数，迭代结束生成的即为最优路径。关于总路径数的问题，我用一个diffpath变量，在迭代中根据父节点的情况来递推子节点的路径数。</p>
<p>具体见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> name=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">int</span> glad=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">vector</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;City&gt; c(<span class="number">26</span> * <span class="number">26</span> * <span class="number">26</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFINITE = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hah</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">	result += <span class="number">26</span> * <span class="number">26</span> * (s[<span class="number">0</span>] - <span class="string">'A'</span>);</span><br><span class="line">	result += <span class="number">26</span> * (s[<span class="number">1</span>] - <span class="string">'A'</span>);</span><br><span class="line">	result += (s[<span class="number">2</span>] - <span class="string">'A'</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">string</span> temps;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; temps;</span><br><span class="line">	<span class="keyword">int</span> start = hah(temps);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myc;</span><br><span class="line">	myc.push_back(start);</span><br><span class="line">	c[start].name = temps;</span><br><span class="line">	c[start].index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temps &gt;&gt; temp;</span><br><span class="line">		c[hah(temps)].name = temps;</span><br><span class="line">		c[hah(temps)].glad = temp;</span><br><span class="line">		myc.push_back(hah(temps));</span><br><span class="line">		c[hah(temps)].index = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> temps1, temps2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temps1 &gt;&gt; temps2 &gt;&gt; temp;</span><br><span class="line">		<span class="keyword">int</span> temp1 = hah(temps1);</span><br><span class="line">		<span class="keyword">int</span> temp2 = hah(temps2);</span><br><span class="line">		c[temp1].link.push_back(&#123;temp2,temp &#125;);</span><br><span class="line">		c[temp2].link.push_back(&#123; temp1,temp &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; collect(n,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n+<span class="number">1</span>, INFINITE);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; glad(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; passnum(n+<span class="number">1</span>,INFINITE);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffpath(n, <span class="number">0</span>);</span><br><span class="line">	dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	passnum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	diffpath[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> v=n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (collect[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (dist[i] &lt; dist[v]) &#123;</span><br><span class="line">				v = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (dist[i] == dist[v]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (glad[i] &gt; glad[v]) v = i;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (glad[i] == glad[v]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (passnum[i] &lt; passnum[v]) v = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (v == n) <span class="keyword">break</span>;</span><br><span class="line">		collect[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> now = myc[v];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c[now].link.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> cty = c[now];</span><br><span class="line">			<span class="keyword">if</span> (collect[c[cty.link[i].first].index]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">auto</span> nextcty = c[cty.link[i].first];</span><br><span class="line">			<span class="keyword">int</span> cost = cty.link[i].second;</span><br><span class="line">			<span class="keyword">if</span> (dist[nextcty.index] &gt; dist[cty.index] + cost) &#123;</span><br><span class="line">				<span class="comment">//刷新路径数为父节点的路径数</span></span><br><span class="line">				diffpath[nextcty.index] = diffpath[cty.index];</span><br><span class="line">				dist[nextcty.index] = dist[cty.index] + cost;</span><br><span class="line">				path[nextcty.index] = cty.index;</span><br><span class="line">				glad[nextcty.index] = glad[cty.index] + nextcty.glad;</span><br><span class="line">				passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (dist[nextcty.index] == dist[cty.index] + cost) &#123;</span><br><span class="line">				<span class="comment">//刷新路径数为本身路径数加上新增同等地位父节点的路径数</span></span><br><span class="line">				diffpath[nextcty.index]+=diffpath[cty.index];</span><br><span class="line">				<span class="keyword">if</span> (glad[nextcty.index] &lt; glad[cty.index] + nextcty.glad) &#123;</span><br><span class="line">					path[nextcty.index] = cty.index;</span><br><span class="line">					glad[nextcty.index] = glad[cty.index] + nextcty.glad;</span><br><span class="line">					passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (glad[nextcty.index] == glad[cty.index] + nextcty.glad) &#123;</span><br><span class="line">					<span class="keyword">if</span> (passnum[nextcty.index] &gt; passnum[cty.index] + <span class="number">1</span>) &#123;</span><br><span class="line">						path[nextcty.index] = cty.index;</span><br><span class="line">						passnum[nextcty.index] = passnum[cty.index] + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">	<span class="keyword">int</span> cty = c[hah(<span class="string">"ROM"</span>)].index;</span><br><span class="line">	<span class="keyword">int</span> dis = cty;</span><br><span class="line">	<span class="keyword">int</span> totselect;</span><br><span class="line">	<span class="keyword">while</span> (cty != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">stack</span>.push_back(cty);</span><br><span class="line">		cty = path[cty];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; diffpath[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; dist[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; glad[dis] &lt;&lt; <span class="string">' '</span> &lt;&lt; glad[dis] / (<span class="keyword">int</span>)passnum[dis] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">bool</span> first = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (first) first = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c[myc[<span class="built_in">stack</span>.back()]].name;</span><br><span class="line">		<span class="built_in">stack</span>.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 为了加快城市关系建立，引入了一个哈希表，可能有些多余，反而使代码结构看起来有些杂乱。</p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1082 Read Number in Chinese</title>
    <url>/2019/10/17/PTA1082-Read-Number-in-Chinese/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai.</p><a id="more"></a>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-123456789</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100800</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yi Shi Wan ling ba Bai</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>可以按每四位来组织数字段，每个数字段有一个后缀，比如1-4位后缀为“”，5-8位后缀为“Wan”，9位后缀为“Yi”，每个数字段单独组织语言，如果数字段不全为0则加上相应后缀。每个数字段负责构造一个堆栈，栈顶为高位数字的对应字符串。、</p>
<p>0的处理：0的出现有以下几种情况</p>
<ul>
<li>高位0，比如0123，在栈顶加“ling”。</li>
<li>中间0，比如1203，在栈的中间位置加“ling”。</li>
<li>低位0，比如1230，不加。</li>
<li>全0，堆栈只有一个元素“ling”。</li>
</ul>
<p>将几个数字段的堆栈拼接为一个堆栈，栈顶为高位数字。<br>注意，还要对0进行后处理，因为之前对全0的处理方式会导致下面几个问题：</p>
<ul>
<li>0重复，比如1-0000-0100</li>
<li>出现低位上0，比如1000-0000</li>
</ul>
<p>因此，最后还要去除堆栈中重复的零，和栈底的零；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (first) first = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> num;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ds&#123; <span class="string">"ling"</span>,<span class="string">"yi"</span>,<span class="string">"er"</span>,<span class="string">"san"</span>,<span class="string">"si"</span>,<span class="string">"wu"</span>,<span class="string">"liu"</span>,<span class="string">"qi"</span>,<span class="string">"ba"</span>,<span class="string">"jiu"</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name1&#123;<span class="string">""</span>, <span class="string">" Shi"</span>,<span class="string">" Bai"</span>,<span class="string">" Qian"</span> &#125;; </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name2&#123;<span class="string">""</span>, <span class="string">" Wan"</span>,<span class="string">" Yi"</span> &#125;;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">stack</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="string">"0"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ling"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">		print(<span class="string">"Fu"</span>);</span><br><span class="line">		num.erase(num.begin());</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(num.begin(), num.end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size()/<span class="number">4</span>+(num.size()%<span class="number">4</span>?<span class="number">1</span>:<span class="number">0</span>); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">4</span>; j &lt; num.size() &amp;&amp; j &lt; (i + <span class="number">1</span>) * <span class="number">4</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">string</span> temp;</span><br><span class="line">			<span class="keyword">if</span> (num[j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">stack</span>[i].empty() &amp;&amp; <span class="built_in">stack</span>[i].back() != <span class="string">"ling"</span> &amp;&amp; <span class="built_in">stack</span>[i].back() != <span class="string">"Wan"</span>) <span class="built_in">stack</span>[i].push_back(<span class="string">"ling"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp += ds[num[j] - <span class="string">'0'</span>];</span><br><span class="line">			temp += name1[j % <span class="number">4</span>];</span><br><span class="line">			<span class="built_in">stack</span>[i].push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果全零</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">stack</span>.empty()) <span class="built_in">stack</span>[i].push_back(<span class="string">"ling"</span>);</span><br><span class="line">		<span class="comment">//不全零，则在栈底加上后缀</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">stack</span>[i].front() += name2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		s.insert(s.end(),<span class="built_in">stack</span>[i].begin(), <span class="built_in">stack</span>[i].end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it &lt; s.end() - <span class="number">1</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">"ling"</span> &amp;&amp; *(it + <span class="number">1</span>) == <span class="string">"ling"</span>) it = s.erase(it);</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it &lt; s.end();) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">"ling"</span>) it = s.erase(it);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">		print(s.back());</span><br><span class="line">		s.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较简洁，并且可拓展性比较强，当题目的位数限制提高后也能适用</p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1074 反转链表</title>
    <url>/2019/10/14/PTA1074-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<h2 id="解题关键"><a href="#解题关键" class="headerlink" title="解题关键"></a>解题关键</h2><p>用哈希表存储链表，在链表头需要另外插入一个空节点指向原链表头。<br>反转的迭代中需要三个临时指针，分别指向被反转节点及其之前、之后的位置。注意逆转节点段头尾的处理。注意链表尾边界情况的处理。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> key=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> val; </span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; ahash(<span class="number">100001</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root, n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; root &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> temp1, temp2, temp3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temp1 &gt;&gt; temp2 &gt;&gt; temp3;</span><br><span class="line">		ahash[temp1] = Node(&#123; temp1,temp2,temp3 &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	ahash[<span class="number">100000</span>].next = root;</span><br><span class="line">	<span class="keyword">int</span> it, preit, postit; <span class="comment">//分别指向节点段的末尾，节点段之前，节点段之后</span></span><br><span class="line">	it = root;</span><br><span class="line">	preit = <span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (it != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count != k) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			it = ahash[it].next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			postit = ahash[it].next;</span><br><span class="line">			<span class="keyword">int</span> tempit= ahash[preit].next;</span><br><span class="line">			<span class="keyword">int</span> tempit_ = ahash[tempit].next;</span><br><span class="line">			<span class="keyword">int</span> tempit__ = ahash[tempit_].next;</span><br><span class="line">			<span class="keyword">while</span>(tempit != it) &#123;</span><br><span class="line">				ahash[tempit_].next = tempit;</span><br><span class="line">				tempit = tempit_;</span><br><span class="line">				tempit_ = tempit__;</span><br><span class="line">				<span class="comment">//注意处理边界情况</span></span><br><span class="line">				<span class="keyword">if</span> (tempit__ != <span class="number">-1</span>)</span><br><span class="line">					tempit__ = ahash[tempit__].next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> newpre = ahash[preit].next;</span><br><span class="line">			ahash[newpre].next = postit;</span><br><span class="line">			ahash[preit].next = it;</span><br><span class="line"></span><br><span class="line">			preit = newpre;</span><br><span class="line">			it = postit;</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ahash[<span class="number">100000</span>].next; i != <span class="number">-1</span>; i = ahash[i].next) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ahash[i].next == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>, ahash[i].key, ahash[i].val);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, ahash[i].key, ahash[i].val, ahash[i].next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA1038 数字段排序</title>
    <url>/2019/10/14/PTA1038-%E6%95%B0%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//核心，判断哪个数字段排前面的算法</span></span><br><span class="line"><span class="comment">//局部规划+贪婪？，本质上就是先乱序建立好一个数字段，</span></span><br><span class="line"><span class="comment">//交换两个数字段，如果交换后有提升，则采纳；如果无提升，就不采纳</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lhs, <span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> temp1 = lhs + rhs;</span><br><span class="line">	<span class="built_in">string</span> temp2 = rhs + lhs;</span><br><span class="line">	<span class="keyword">if</span> (temp1 &lt; temp2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (temp1 == temp2 &amp;&amp; temp1.size() &lt; temp2.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nums;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">string</span> temp;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">		nums.push_back(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(nums.begin(), nums.end(),cmp);</span><br><span class="line">	<span class="built_in">string</span> result;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">		result += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输入参数全0的情况</span></span><br><span class="line">	<span class="keyword">int</span> off = result.find_first_not_of(<span class="string">'0'</span>);</span><br><span class="line">	<span class="keyword">if</span> (off == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; result.substr(off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/14/myFirstTry/</url>
    <content><![CDATA[<h1 id="Winger强势入场"><a href="#Winger强势入场" class="headerlink" title="Winger强势入场"></a>Winger强势入场</h1><p>2019-10-14 经历了各种艰难，这个博客走起来了</p>
<img src="/2019/10/14/myFirstTry/1.jpg" title="走起！">]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
</search>
